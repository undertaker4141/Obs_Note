# 有號數運算與旗標

本節介紹 ARM 處理器中的有號數運算指令及其對旗標的影響，包括加法、減法、乘法等操作。

## 有號數運算與旗標的關係

在 ARM 處理器中，有號數運算會影響 CPSR (目前程式狀態暫存器) 中的旗標，特別是：

- **N (Negative)**：結果為負數時設置 (等於結果的最高位)
- **Z (Zero)**：結果為零時設置
- **C (Carry)**：無號數加法產生進位或減法無借位時設置
- **V (Overflow)**：有號數運算結果超出範圍時設置

其中，V 旗標對有號數運算特別重要，它指示運算結果是否超出了有號數的表示範圍。

## 溢位 (Overflow) 的概念

溢位發生在有號數運算結果超出其表示範圍時：

- **正溢位**：當兩個正數相加，結果太大而變成負數
- **負溢位**：當兩個負數相加，結果太小而變成正數

### 溢位的判斷

V 旗標的設置基於以下規則：

- 加法：當兩個相同符號的數相加，結果符號與操作數不同時
- 減法：當兩個不同符號的數相減，結果符號與第一個操作數不同時

在硬體層面，V 旗標的計算公式為：
```
V = (進入符號位的進位) XOR (從符號位出來的進位)
```

## 有號數加法

```assembly
ADDS Rd, Rn, Op2    ; Rd = Rn + Op2，並更新旗標
```

加法指令 ADDS 會更新所有旗標，包括 V 旗標。

**範例**：
```assembly
    MOV R0, #0x7FFFFFFF    ; 最大正數 (2^31-1)
    MOV R1, #1
    ADDS R2, R0, R1        ; R2 = R0 + R1，會導致溢位
    ; 結果：R2 = 0x80000000 (負數)，N=1, Z=0, C=0, V=1
```

## 有號數減法

```assembly
SUBS Rd, Rn, Op2    ; Rd = Rn - Op2，並更新旗標
```

減法指令 SUBS 會更新所有旗標，包括 V 旗標。

**範例**：
```assembly
    MOV R0, #0x80000000    ; 最小負數 (-2^31)
    MOV R1, #1
    SUBS R2, R0, R1        ; R2 = R0 - R1，會導致溢位
    ; 結果：R2 = 0x7FFFFFFF (正數)，N=0, Z=0, C=0, V=1
```

## 有號數乘法

ARM 提供了多種有號數乘法指令：

### 基本乘法

```assembly
MUL Rd, Rn, Rm     ; Rd = Rn * Rm (低 32 位)
MULS Rd, Rn, Rm    ; 同上，並更新 N, Z 旗標 (不更新 C, V)
```

基本乘法指令執行 32x32 → 32 位元乘法，只保留結果的低 32 位。

### 64 位元有號數乘法

```assembly
SMULL RdLo, RdHi, Rn, Rm    ; {RdHi,RdLo} = Rn * Rm (有號數)
SMULLS RdLo, RdHi, Rn, Rm   ; 同上，並更新旗標
```

這些指令執行 32x32 → 64 位元有號數乘法，結果的低 32 位存入 RdLo，高 32 位存入 RdHi。

### 有號數乘加

```assembly
MLA Rd, Rn, Rm, Ra    ; Rd = Rn * Rm + Ra
MLAS Rd, Rn, Rm, Ra   ; 同上，並更新旗標
```

乘加指令 (Multiply-Accumulate) 執行乘法後再加上第三個操作數。

### 64 位元有號數乘加

```assembly
SMLAL RdLo, RdHi, Rn, Rm    ; {RdHi,RdLo} = {RdHi,RdLo} + Rn * Rm
SMLALS RdLo, RdHi, Rn, Rm   ; 同上，並更新旗標
```

這些指令將 32x32 位元有號數乘法結果加到 64 位元累加器 {RdHi,RdLo} 中。

## 有號數除法

某些 ARM 核心 (如 Cortex-M3/M4) 支援硬體有號數除法指令：

```assembly
SDIV Rd, Rn, Rm    ; Rd = Rn / Rm (有號數)
```

對於不支援硬體除法的核心，可以使用軟體實現。

## 算術右移 (ASR)

算術右移是一種特殊的右移操作，專為有號數設計：

```assembly
ASR Rd, Rm, #n     ; Rd = Rm >> n (有號數)
ASRS Rd, Rm, #n    ; 同上，並更新旗標
```

算術右移將 Rm 中的所有位元向右移動 n 位，但保持符號位不變（高位填充原始符號位）。

**特性**：
- 每右移一位，值除以 2 (有號數)
- 保持符號不變
- 高位填充原始符號位

**範例**：
```assembly
    MOV R0, #-20       ; R0 = -20 (0xFFFFFFEC)
    ASR R0, R0, #2     ; R0 = -5 (0xFFFFFFFB)，右移 2 位，高位填充 1
```

## 有號數運算範例

### 有號數加法檢查溢位

```assembly
    ; 執行有號數加法並檢查溢位
    ADDS R0, R1, R2    ; R0 = R1 + R2，更新旗標
    BVS Overflow       ; 如果發生溢位，跳轉到 Overflow 處理
    ; 正常處理...
    
Overflow:
    ; 溢位處理...
```

### 有號數乘法

```assembly
    ; 計算 64 位元有號數乘法結果
    MOV R0, #-1000     ; 第一個操作數
    MOV R1, #2000      ; 第二個操作數
    SMULL R2, R3, R0, R1  ; {R3,R2} = R0 * R1
    ; 結果：R2 = 0xF0BDC000, R3 = 0xFFFFFFFF (表示 -2,000,000)
```

### 有號數除法

```assembly
    ; 執行有號數除法
    MOV R0, #-100      ; 被除數
    MOV R1, #3         ; 除數
    SDIV R2, R0, R1    ; R2 = R0 / R1
    ; 結果：R2 = -33
    
    ; 計算餘數
    MUL R3, R2, R1     ; R3 = 商 * 除數
    SUB R4, R0, R3     ; R4 = 被除數 - (商 * 除數) = 餘數
    ; 結果：R4 = -1
```

## 有號數運算的最佳實踐

1. **溢位檢查**：
   - 在關鍵有號數運算後檢查 V 旗標
   - 實現適當的溢位處理策略

2. **範圍限制**：
   - 在可能的情況下，確保操作數在安全範圍內
   - 考慮使用飽和算術 (saturation arithmetic) 防止溢位

3. **64 位元結果**：
   - 對於可能產生大結果的乘法，使用 SMULL 而非 MUL
   - 對於需要高精度的計算，考慮使用 64 位元或更高精度

4. **除法替代**：
   - 在不支援硬體除法的平台上，考慮使用移位操作代替除以 2 的冪次方
   - 對於其他除數，考慮使用查表法或迭代算法

## 返回

- [[ARM有號整數運算|返回第五章目錄]]
- [[微處理機概述|返回微處理機概述]]
