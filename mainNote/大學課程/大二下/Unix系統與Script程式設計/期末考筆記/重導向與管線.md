# 重導向與管線 (Redirection and Piping)

(來源: c11_redirection_and_piping.pdf)

## 簡介

電腦軟體 (指令) 通常執行輸入、處理、輸出等操作。作業系統需要決定 Shell 指令從何處獲取輸入、將輸出送到何處，以及錯誤訊息送到何處。

## 標準檔案 (Standard Files)

UNIX 中，核心會為每個指令自動開啟三個檔案：

1. **標準輸入 (stdin)**：檔案描述符 (file descriptor) 為 `0`。預設為鍵盤。
    
2. **標準輸出 (stdout)**：檔案描述符為 `1`。預設為螢幕。
    
3. **標準錯誤 (stderr)**：檔案描述符為 `2`。預設為螢幕。
    

這些檔案預設與指令執行的終端機相關聯。

## 輸入重導向 (`<`)

- 將指令的標準輸入從鍵盤改為指定的檔案。
    
- **語法**: `command < input-file`
    
- 範例：
    
    - `cat < tempfile`：`cat` 從 `tempfile` 讀取內容並輸出到螢幕。
        
    - `grep "John" < Phones`：`grep` 從 `Phones` 檔案搜尋 "John"。
        
    - `tr -s ' ' '\t' < Bigfile`：`tr` 從 `Bigfile` 讀取，將多個空格替換為單個定位字元。
        

## 輸出重導向 (`>`)

- 將指令的標準輸出從螢幕改為指定的檔案。標準錯誤仍輸出到螢幕。
    
- **語法**: `command > output-file`
    
- 如果 `output-file` 已存在，其內容會被 **覆寫**。如果不存在，則建立新檔案。
    
- 範例：
    
    - `cat > newfile`：從鍵盤讀取輸入，直到 `<Ctrl+D>`，內容存入 `newfile`。
        
    - `grep "John" Phones > Phone_John`：搜尋結果存入 `Phone_John`。
        
    - `ssh server sort < datafile > sorted_datafile_on_client` (假設 `datafile` 在客戶端，排序在伺服器端完成，結果存回客戶端的 `sorted_datafile_on_client`)。
        

## 附加輸出 (`>>`)

- 將指令的標準輸出附加到指定檔案的末尾。如果檔案不存在，則建立它。
    
- **語法**: `command >> output-file`
    
- 範例：`ls -l >> file_list.txt`：將 `ls -l` 的結果附加到 `file_list.txt`。
    

## 結合輸入與輸出重導向

- **語法**:
    
    - `command < input-file > output-file`
        
    - `command > output-file < input-file` (順序不影響基本功能，但影響錯誤訊息重導向時的行為)
        
- 範例：`sort < unsorted.txt > sorted.txt`：從 `unsorted.txt` 讀取，排序後結果寫入 `sorted.txt`。
    

## 使用檔案描述符重導向 (Bourne, Korn, Bash, POSIX Shell)

- `0<`: 明確指定標準輸入重導向 (等同於 `<`)。
    
- `1>`: 明確指定標準輸出重導向 (等同於 `>`)。
    
- `2>`: 重導向標準錯誤。
    
    - `command 2> error-file`：將 `command` 的錯誤訊息寫入 `error-file`。
        
- **同時重導向 stdout 和 stderr 到不同檔案**:
    
    - `command 1> output-file 2> error-file`
        
- **同時重導向 stdout 和 stderr 到相同檔案**:
    
    - `command > file 2>&1` (先將 stdout 重導向到 `file`，然後將 stderr 重導向到 stdout 目前指向的地方，即 `file`)
        
    - `command 2> file 1>&2` (先將 stderr 重導向到 `file`，然後將 stdout 重導向到 stderr 目前指向的地方，即 `file`)
        
    - `command &> file` (Bash/Zsh 特有，更簡潔的寫法)
        
- **附加 stdout 和 stderr 到相同檔案**:
    
    - `command >> file 2>&1`
        

## C Shell 中的輸出與錯誤重導向

- C Shell 不支援直接使用檔案描述符 `0`, `1`, `2` 進行重導向。
    
- `>&`: 將 stdout 和 stderr 同時重導向到檔案 (會覆寫)。
    
    - `command >& file`
        
- `>>&`: 將 stdout 和 stderr 同時附加到檔案末尾。
    
    - `command >>& file`
        
- `|&`: 將 command1 的 stdout 和 stderr 同時透過管線傳給 command2。
    
    - `command1 |& command2`
        

## 管線 (Pipes `|`)

- 將一個指令的標準輸出 (stdout) 連接到另一個指令的標準輸入 (stdin)。
    
- **語法**: `command1 | command2 | command3 | ... | commandN`
    
- 管線中的所有指令並行執行，資料以串流方式在它們之間流動。
    
- 透過管線連接的指令通常稱為 **過濾器 (filters)**：從 stdin 讀取輸入，處理後輸出到 stdout。
    
    - 常用過濾器：`cat`, `compress`, `crypt`, `grep`, `less`, `lp`, `more`, `pr`, `sort`, `tr`, `uniq`, `wc`。
        
- 管線在核心記憶體中實作，比使用暫存檔案進行指令間資料傳遞更有效率。
    
- 範例：
    
    - `ls -l | more`：分頁顯示長列表。
        
    - `who | sort | grep "john" | mail -s "John's Terminal" doe@example.com`：將登入使用者排序後，找出含 "john" 的行，並將結果郵寄。
        

## 結合重導向與管線 (`tee`)

- 不能直接在同一個指令的 stdout 上同時使用檔案重導向 (`>`) 和管線 (`|`)，因為它們會競爭 stdout。
    
- `tee` 指令：從標準輸入讀取，並將其內容同時寫入標準輸出和一個或多個檔案。
    
- **語法**: `command1 | tee file1 [file2 ...] | command2`
    
- `command1` 的輸出會被送到 `tee`，`tee` 會將其寫入 `file1` (以及 `file2` 等)，同時也將其透過管線傳給 `command2`。
    
- 範例：`cat names students | grep "John Doe" | tee matches.txt | wc -l`：從 `names` 和 `students` 搜尋 "John Doe"，匹配的行存入 `matches.txt`，同時計算匹配行數並顯示。
    

## FIFOs (具名管線 Named Pipes)

- 也稱為具名管線，允許同一系統上兩個不一定相關的行程進行通訊。
    
- 與一般 (匿名) 管線的差異：
    
    - **建立方式**: 使用 `mkfifo` 指令或 `mkfifo()`/`mknod()` 系統呼叫明確建立。
        
    - **存在形式**: 在檔案系統中以一個特殊檔案類型 (`p`) 的名稱存在。
        
    - **生命週期**: 通常是檔案系統持續性的 (filesystem persistent)，直到被明確刪除或檔案系統卸載。匿名管線是行程持續性的 (process persistent)。
        
- **語法**: `mkfifo [option] fifo_name`
    
    - `-m mode`: 設定 FIFO 的權限 (如 `666`)。
        
- **使用範例**:
    
    1. `mkfifo myfifo1`
        
    2. 在一個終端執行讀取端 (會阻塞直到有寫入): `command_reads < myfifo1 &`
        
    3. 在另一個終端執行寫入端: `command_writes > myfifo1` 或者結合 `tee`: `producer_command | tee myfifo1 | consumer_command1`，同時 `consumer_command2 < myfifo1`。
        
- 移除 FIFO：使用 `rm fifo_name`。
    

[[Unix學習筆記_總覽]]