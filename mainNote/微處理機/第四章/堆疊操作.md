# 堆疊操作

本節介紹 ARM 處理器中的堆疊 (Stack) 操作，包括堆疊的基本概念、PUSH/POP 指令以及堆疊的初始化和用途。

## 堆疊基本概念

堆疊是 RAM 中的一塊特殊區域，採用後進先出 (LIFO, Last-In-First-Out) 的資料結構。堆疊主要用於：
- 暫時儲存暫存器的值
- 保存副程式的返回位址
- 傳遞參數
- 配置區域變數

## 堆疊指標 (SP)

堆疊指標 (Stack Pointer, SP, R13) 是一個特殊的暫存器，用於指向堆疊的頂部。在 ARM 處理器中，堆疊向下增長：
- PUSH 操作：SP 先減少，再儲存資料
- POP 操作：先載入資料，再增加 SP

## PUSH 和 POP 指令

### PUSH 指令

```assembly
PUSH {reglist}    ; 將暫存器列表中的值壓入堆疊
```

PUSH 指令執行以下操作：
1. 計算新的 SP 值：SP = SP - (4 * 暫存器數量)
2. 將暫存器列表中的值依序儲存到堆疊中
3. 暫存器的儲存順序是從最低編號到最高編號

**範例**：
```assembly
PUSH {R0-R3, LR}    ; 將 R0, R1, R2, R3, LR 壓入堆疊
```

這個指令實際上是 `STMDB SP!, {R0-R3, LR}` 的偽指令。

### POP 指令

```assembly
POP {reglist}    ; 從堆疊彈出值到暫存器列表
```

POP 指令執行以下操作：
1. 從堆疊中依序載入值到暫存器列表
2. 暫存器的載入順序是從最低編號到最高編號
3. 更新 SP 值：SP = SP + (4 * 暫存器數量)

**範例**：
```assembly
POP {R0-R3, PC}    ; 從堆疊彈出值到 R0, R1, R2, R3, PC
```

這個指令實際上是 `LDMIA SP!, {R0-R3, PC}` 的偽指令。

## 堆疊初始化

堆疊必須在使用前初始化。通常，堆疊指標 (SP) 初始化為堆疊區域的最高位址 + 1：

```assembly
LDR SP, =StackTop    ; 初始化堆疊指標
```

其中 `StackTop` 是堆疊區域的最高位址 + 1。

在 ARM Cortex-M 處理器中，SP 的初始值通常從位址 0x00000000 讀取，這個位址包含堆疊頂部的位址。這是在啟動程式碼 (startup code) 中設定的。

## 堆疊配置

堆疊區域通常在連結器腳本 (linker script) 中定義。以下是一個簡單的堆疊配置範例：

```
MEMORY
{
    FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 64K
    RAM (rwx)  : ORIGIN = 0x20000000, LENGTH = 20K
}

SECTIONS
{
    .text :
    {
        *(.text*)
    } > FLASH
    
    .data :
    {
        *(.data*)
    } > RAM
    
    .bss :
    {
        *(.bss*)
    } > RAM
    
    /* 堆疊配置 */
    .stack :
    {
        . = ALIGN(8);
        __stack_start = .;
        . = . + 0x1000;    /* 4KB 堆疊 */
        . = ALIGN(8);
        __stack_end = .;
    } > RAM
}

/* 設定堆疊頂部 */
__stack_top = __stack_end;
```

在啟動程式碼中，可以這樣初始化堆疊：

```assembly
    LDR R0, =__stack_top
    MOV SP, R0    ; 初始化主堆疊指標 (MSP)
```

## 堆疊框架 (Stack Frame)

堆疊框架是在函式呼叫期間在堆疊上配置的一塊區域，用於儲存：
- 返回位址
- 被呼叫者保存的暫存器
- 區域變數
- 參數 (如果需要)

### 基本堆疊框架

```assembly
MyFunction:
    ; 函式序言 (Prologue)
    PUSH {R4-R7, LR}    ; 保存被呼叫者保存的暫存器和返回位址
    SUB SP, SP, #16     ; 為區域變數配置 16 位元組
    
    ; 函式主體
    ...
    
    ; 函式結語 (Epilogue)
    ADD SP, SP, #16     ; 釋放區域變數
    POP {R4-R7, PC}     ; 恢復暫存器並返回
```

### 存取堆疊上的區域變數

```assembly
    ; 假設已配置堆疊空間
    STR R0, [SP, #0]    ; 儲存 R0 到第一個區域變數
    STR R1, [SP, #4]    ; 儲存 R1 到第二個區域變數
    
    ; 稍後存取這些變數
    LDR R0, [SP, #0]    ; 載入第一個區域變數到 R0
    LDR R1, [SP, #4]    ; 載入第二個區域變數到 R1
```

## 堆疊的用途

### 保存暫存器值

```assembly
    ; 需要使用 R4-R7，但想保留它們的原始值
    PUSH {R4-R7}    ; 保存 R4-R7
    
    ; 使用 R4-R7 進行計算
    ...
    
    POP {R4-R7}     ; 恢復 R4-R7 的原始值
```

### 巢狀副程式呼叫

```assembly
Function1:
    PUSH {LR}       ; 保存返回位址
    BL Function2    ; 呼叫另一個函式
    POP {PC}        ; 恢復返回位址並返回
    
Function2:
    ; 函式主體
    BX LR           ; 返回 Function1
```

### 傳遞額外參數

當參數超過 4 個時，額外的參數通過堆疊傳遞：

```assembly
    ; 呼叫具有 6 個參數的函式
    MOV R0, #1      ; 參數 1
    MOV R1, #2      ; 參數 2
    MOV R2, #3      ; 參數 3
    MOV R3, #4      ; 參數 4
    
    ; 額外參數通過堆疊傳遞 (從右到左)
    MOV R12, #6     ; 參數 6
    PUSH {R12}      ; 壓入堆疊
    MOV R12, #5     ; 參數 5
    PUSH {R12}      ; 壓入堆疊
    
    BL Function     ; 呼叫函式
    
    ADD SP, SP, #8  ; 清理堆疊 (2 個參數 * 4 位元組)
```

## 堆疊溢位 (Stack Overflow)

堆疊溢位是一種常見的錯誤，發生在堆疊增長超出其分配的空間時。這可能導致：
- 程式崩潰
- 資料損壞
- 安全漏洞

為了避免堆疊溢位：
- 分配足夠的堆疊空間
- 避免過深的遞迴
- 避免在堆疊上配置過大的區域變數
- 考慮使用堆積 (Heap) 而非堆疊來配置大型資料結構

## 返回

- [[ARM分支呼叫與迴圈|返回第四章目錄]]
- [[微處理機概述|返回微處理機概述]]
