---
banner: 模板/banner.jpg
banner_y: "87.5"
---
# 演算法筆記 第 11 講：最短路徑 (Shortest Paths)

[[演算法筆記_總覽與考試重點]]

## 最短路徑問題概述

最短路徑問題是在一個帶權重的圖中，找到從一個指定的源頂點 (source vertex) s 到另一個目標頂點 t (或所有其他頂點) 的權重總和最小的路徑。

### 問題的種類

1. **單源最短路徑 (Single-Source Shortest Paths, SSSP):** 從單一源點 s 到圖中所有其他頂點的最短路徑。這是本講的重點。
    
2. **單目的地最短路徑 (Single-Destination Shortest Paths):** 從所有頂點到單一目標點 t 的最短路徑。可以通過在反向圖 (所有邊方向顛倒) 上，以 t 為源點運行 SSSP 解決。
    
3. **點對點最短路徑 (Source-Sink / Point-to-Point Shortest Path):** 從特定源點 s 到特定目標點 t 的最短路徑。通常，SSSP 演算法可以解決這個問題 (找到到所有點的路徑後，選取到 t 的路徑，或在演算法運行至 t 被處理後即停止)。
    
4. **所有點對最短路徑 (All-Pairs Shortest Paths, APSP):** 找到圖中每對頂點 (u,v) 之間的最短路徑。可以對每個頂點運行 SSSP (例如，若邊權非負，則運行 V 次 Dijkstra)，或者使用如 Floyd-Warshall (一種動態規劃演算法，將在後續章節討論) 這樣的特定演算法。
    

### 資料結構與定義

- **邊權重有向圖 (Edge-Weighted Digraph):** 邊上帶有數值 (權重) 的有向圖。權重可以代表距離、成本、時間等。
    
- **路徑權重 (Path Weight):** 一條路徑上所有邊的權重之和。
    
- `distTo[v]`: 從源點 s 到頂點 v 的**當前已知**最短路徑的長度 (權重總和)。初始時，`distTo[s] = 0`，對所有其他 v=s，`distTo[v] = \infty$。
    
- `edgeTo[v]`: 一個指向 `DirectedEdge` 物件的陣列，`edgeTo[v]` 存儲的是從 s 到 v 的**當前已知**最短路徑上的最後一條邊。用於重建最短路徑。
    

### 邊的鬆弛 (Edge Relaxation)

鬆弛是大多數最短路徑演算法的核心操作。對於一條有向邊 e=(u→v)，其權重為 `e.weight()`： 如果從 s 到 u 的已知最短路徑長度 (`distTo[u]`) 加上邊 e 的權重，小於從 s 到 v 的已知最短路徑長度 (`distTo[v]`)，則我們找到了一條更短的到達 v 的路徑 (經由 u)。 此時，更新：

- `distTo[v] = distTo[u] + e.weight()`
    
- `edgeTo[v] = e`
    

```
// 鬆弛操作的虛擬碼
private void relax(DirectedEdge e) {
    int u = e.from(); // 講義中用 v 代表起點
    int w = e.to();   // 講義中用 w 代表終點
    if (distTo[w] > distTo[u] + e.weight()) {
        distTo[w] = distTo[u] + e.weight();
        edgeTo[w] = e;
        // 如果使用優先佇列，可能需要更新 w 在佇列中的優先級
        // if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
        // else pq.insert(w, distTo[w]);
    }
}
```

### 最短路徑樹 (Shortest-Paths Tree, SPT)

對於一個源點 s，其 SPT 是一棵包含 s 和從 s 可達的所有頂點的樹，使得從 s 到樹中任何其他頂點 v 的路徑都是原圖中的最短路徑。`edgeTo[]` 陣列隱含地表示了這棵樹 (父連結表示法)。

### 限制條件

- **邊權重 (Edge Weights):**
    
    - **非負權重:** Dijkstra 演算法要求所有邊的權重都是非負的。
        
    - **任意權重 (含負權重):** Bellman-Ford 演算法和基於拓撲排序的 DAG 演算法可以處理負權重邊。
        
- **環 (Cycles):**
    
    - **無有向環 (DAGs):** 對於有向無環圖，即使有負權重邊，也可以在線性時間內解決 SSSP 問題。
        
    - **負權環 (Negative Cycles):** 如果圖中存在從源點 s 可達的負權環 (環上邊權重之和為負)，則從 s 到該環上某些頂點 (以及從這些頂點可達的頂點) 的最短路徑是**沒有定義的** (或可視為 −∞)。因為我們可以無限次地沿著這個負權環繞行，使得路徑長度無限減小。Bellman-Ford 演算法可以檢測負權環。
        

## Dijkstra 演算法 [[演算法筆記_總覽與考試重點]]

Dijkstra 演算法由 Edsger W. Dijkstra 於 1956 年提出，用於解決帶有**非負權重邊**的單源最短路徑問題。它是一種貪婪演算法，逐步建立最短路徑樹。

### 核心思想 (Greedy Approach)

1. 維護一個頂點集合 T (SPT set)，其中包含所有已找到最短路徑的頂點。初始時，T 只包含源點 s。
    
2. 對於所有 v∈/T，`distTo[v]` 存儲從 s 出發，只經過 T 中的頂點 (除了 v 本身，如果 v 是下一個要加入的點) 到達 v 的最短路徑長度。
    
3. 在每一步，從 V−T (所有不在 T 中的頂點) 中選擇一個頂點 u，使得 `distTo[u]` 最小 (即當前看來到 s 距離最近的頂點)。
    
4. 將 u 加入 T。此時，`distTo[u]` 就是 s 到 u 的真正最短路徑長度。
    
5. 對於所有從 u 出發的邊 (u→v)，進行鬆弛操作。如果 v∈/T，並且通過 u 可以縮短到 v 的路徑，則更新 `distTo[v]` 和 `edgeTo[v]`。
    
6. 重複步驟 3-5，直到所有頂點都被加入 T (或者，如果使用優先佇列，直到優先佇列為空)。
    

### 演算法步驟 (使用索引最小優先佇列 `IndexMinPQ`)

1. **初始化:**
    
    - `distTo[v] = \infty` 對於所有 v=s；`distTo[s] = 0.0`。
        
    - `edgeTo[v] = null` 對於所有 v。
        
    - 創建一個索引最小優先佇列 `pq`。`pq` 存儲的是 `(頂點索引, distTo[頂點索引])`，並根據 `distTo` 值排序。
        
    - 將 `(s, 0.0)` 插入 `pq`。
        
2. **主迴圈:** 當 `pq` 不為空時： a. 從 `pq` 中刪除並返回具有最小 `distTo` 值的頂點 u (`u = pq.delMin()`)。這個頂點 u 的最短路徑已經確定。 b. 對於從 u 出發的每一條邊 e=(u→v): i. 執行鬆弛操作 `relax(e)`。 ii. 如果 `relax(e)` 成功更新了 `distTo[v]` (即找到了更短的路徑到 v)： - 若 v 已在 `pq` 中，則更新其優先級 (`pq.decreaseKey(v, distTo[v])`)。 - 若 v 不在 `pq` 中 (或者某些實現中，即使在也重新插入)，則將 `(v, distTo[v])` 插入 `pq` (`pq.insert(v, distTo[v])`)。
    

### 正確性證明概要 (依賴非負權重)

- **不變式:** 對於已經從優先佇列中取出並加入到 SPT 集合中的頂點 u，`distTo[u]` 是從 s 到 u 的實際最短路徑長度。
    
- **證明思路 (反證法):** 假設當頂點 u 被選為下一個加入 SPT 的頂點時 (即 `distTo[u]` 是所有未處理頂點中最小的)，`distTo[u]` 並非 s 到 u 的最短路徑。那麼必然存在另一條從 s 到 u 的更短路徑 P∗。這條路徑 P∗ 必定會經過某個點 x (已在 SPT 中) 然後通過一條邊 (x→y) 進入未在 SPT 中的點 y (y 可能就是 u 或者在 P∗ 上 u 之前)，最終到達 u。由於邊權重非負，路徑 s⇝y 的長度 (即 `distTo[y]`) 必然小於或等於 P∗ 的長度，因此 `distTo[y]` 會小於 `distTo[u]`。這意味著 y 應該在 u 之前被選中，與 u 是當前 `distTo` 最小的未處理頂點矛盾。
    

### 效能分析

- 使用**二元堆積 (Binary Heap)** 實現 `IndexMinPQ`：
    
    - 初始化 `distTo` 和 `edgeTo`: O(V)。
        
    - 將 s 加入 `pq`: O(logV)。
        
    - 主迴圈執行 V 次 (每個頂點被 `delMin` 一次): V×O(logV)。
        
    - 每條邊 (u→v) 最多被鬆弛一次 (當 u 被 `delMin` 時)。
        
    - 每次鬆弛可能導致一次 `decreaseKey` 或 `insert` 操作。總共有 E 條邊，所以最多 E 次這類操作，每次 O(logV)。
        
    - 總時間複雜度: O(VlogV+ElogV)=O((V+E)logV)。對於連通圖，E≥V−1，所以通常寫作 O(ElogV)。
        
- 使用**斐波那契堆積 (Fibonacci Heap)**：
    
    - `delMin` 仍是 O(logV) (均攤)。
        
    - `decreaseKey` 操作的均攤時間為 O(1)。
        
    - 總時間複雜度: O(E+VlogV)。
        
- **空間複雜度:** O(V+E) (存儲圖) + O(V) (用於 `distTo`, `edgeTo`, `pq`)。
    

### Dijkstra 演算法的限制

- Dijkstra 演算法**不能**正確處理帶有負權重邊的圖。其貪婪策略（總是選擇當前看來距離源點最近的頂點並永久化其距離）在有負邊時可能出錯。因為一條通過較遠頂點的路徑，如果後續經過了權重足夠小的負邊，其總長度可能反而短於直接到達的“看似較近”的路徑。
    

### Dijkstra 與 Prim 演算法的比較

Dijkstra 演算法在概念和實現上與 Prim 演算法求最小生成樹非常相似。兩者都是貪婪地從一個源點開始擴展一棵樹。

- **Prim:** 每次選擇連接樹中頂點與樹外頂點的**權重最小的邊**。目標是連接所有頂點，使得總邊權重最小。它關心的是將頂點連接到**當前已形成的樹**的最小成本。
    
- **Dijkstra:** 每次選擇距離**源點** s 最近的未處理頂點。目標是找到從源點到所有其他頂點的最短路徑。它關心的是從**固定源點**到該頂點的總路徑成本。
    

## 邊權重有向無環圖 (Edge-Weighted DAGs) 的最短路徑

如果圖是有向無環圖 (DAG)，即使邊權重為負，也可以在線性時間內計算單源最短路徑。這是因為 DAG 中不存在環，因此也不會有負權環的問題。

### 演算法步驟

1. **拓撲排序 (Topological Sort):** 計算 DAG 中所有頂點的拓撲序。這會給出一個頂點的線性順序 v1​,v2​,…,vV​，使得對於圖中每條有向邊 (vi​→vj​)，都有 i<j (即 vi​ 在 vj​ 之前)。
    
2. **初始化:**
    
    - `distTo[s] = 0` (其中 s 是源點)。
        
    - 對於所有其他頂點 v=s，`distTo[v] = \infty$。
        
    - `edgeTo[v] = null` 對於所有 v。
        
3. **按拓撲序鬆弛邊:** 按照拓撲排序得到的頂點順序，依次處理每個頂點 u：
    
    - 對於從 u 出發的每一條邊 e=(u→v)：
        
        - 執行鬆弛操作 `relax(e)`。
            

### 正確性與效能

- **正確性:** 當處理頂點 u 時，由於拓撲排序的性質，所有可能指向 u 的頂點都已經在其之前被處理過，因此 `distTo[u]` 已經達到了其最終的最短路徑值。所以，當鬆弛從 u 出發的邊時，是基於已知的到 u 的最短路徑。
    
- **時間複雜度:**
    
    - 拓撲排序: O(V+E)。
        
    - 初始化: O(V)。
        
    - 按拓撲順序遍歷所有頂點，並對每個頂點的所有出邊進行一次鬆弛操作。每條邊只會被鬆弛一次。總鬆弛操作: O(E)。
        
    - 總時間複雜度: O(V+E)。
        
- **應用:** 常用於排程問題 (例如，關鍵路徑法 CPM，其中邊權重可以表示任務持續時間，而負權重可以表示任務間的最早/最晚開始時間約束)。
    

## Bellman-Ford 演算法

Bellman-Ford 演算法用於解決允許**負權重邊**的單源最短路徑問題，並且能夠檢測圖中是否存在從源點可達的**負權環**。

### 核心思想

- **迭代鬆弛:** 演算法對圖中的所有邊進行多輪鬆弛。
    
- **路徑長度與迭代次數:** 如果圖中不存在負權環，從源點 s 到任何頂點 v 的最短路徑最多包含 V−1 條邊。Bellman-Ford 演算法通過 V−1 輪迭代來確保找到這些最短路徑。在第 k 輪迭代結束後，對於所有頂點 v，`distTo[v]` 的值是從 s 到 v 的、最多包含 k 條邊的路徑的最短長度。
    

### 演算法步驟

1. **初始化:**
    
    - `distTo[s] = 0.0`。
        
    - `distTo[v] = \infty` 對於所有 v=s。
        
    - `edgeTo[v] = null` 對於所有 v。
        
2. **迭代鬆弛:**
    
    - 重複 V−1 次 (即進行 V−1 輪，從 `pass = 0` 到 `pass = V-2`)：
        
        - 對於圖中的每一條邊 e=(u→v):
            
            - 執行鬆弛操作 `relax(e)`。
                
3. **檢測負權環 (第** V **輪檢查):**
    
    - 在完成上述 V−1 輪鬆弛後，再遍歷所有邊進行一次檢查 (相當於第 V 輪鬆弛嘗試)：
        
        - 對於圖中的每一條邊 e=(u→v):
            
            - 如果 `distTo[v] > distTo[u] + e.weight()` 仍然成立，則說明圖中存在一個從源點 s 可達的負權環。最短路徑問題對於受該環影響的頂點是無解的 (或為 −∞)。
                

### 效能分析

- 主迴圈迭代 V−1 次。
    
- 在每次迭代中，遍歷所有 E 條邊進行鬆弛。
    
- 檢測負權環需要額外 O(E)。
    
- 總時間複雜度: O(VE)。
    
- 空間複雜度: O(V) (用於 `distTo` 和 `edgeTo`)。
    

###佇列優化的 Bellman-Ford (SPFA - Shortest Path Faster Algorithm)

- **思想:** 在 Bellman-Ford 的每一輪中，許多鬆弛操作可能是不必要的，因為只有那些 `distTo` 值在上一輪被改變的頂點 u 的出邊 (u→v) 才有可能導致 distTo[v] 的更新。
    
- **實現:**
    
    - 維護一個佇列 `queue`，初始時只包含源點 s。
        
    - 一個布林陣列 `onQ[]` 標記頂點是否在佇列中。
        
    - (可選) 一個計數器 `count[v]` 記錄頂點 v 入隊的次數，用於檢測負權環。
        
    - 當 `queue` 不為空時： a. 從 `queue` 中取出一個頂點 u (`u = queue.dequeue()`)，並設置 `onQ[u] = false`。 b. 對於從 u 出發的每一條邊 e=(u→v): i. 執行鬆弛操作 `relax(e)`。 ii. 如果 `distTo[v]` 被更新： - 如果 v 當前不在 `queue` 中 (`!onQ[v]`)，則將 v 加入 `queue` 並設置 `onQ[v] = true`。 - (負權環檢測) 增加 `count[v]`，如果 `count[v] >= V`，則檢測到負權環。
        
- **效能 (SPFA):**
    
    - **最壞情況:** O(VE)。
        
    - **平均/實際情況:** 在許多圖上表現通常遠好於 O(VE)，更接近 O(E+V) 或 O(E)。但由於存在 O(VE) 的最壞情況，它並不總能替代 Bellman-Ford (若需嚴格的 O(VE) 保證) 或 Dijkstra (若邊權非負)。
        

### 最短路徑演算法選擇總結

| 演算法         | 邊權重限制                | 時間複雜度 (最壞情況)       | 額外空間 | 備註                                       |
| -------------- | ------------------------- | -------------------------- | -------- | ------------------------------------------ |
| BFS            | 無權重 (或等權重)           | $O(V+E)$                   | $O(V)$   | 簡單，用於無權圖，找到邊數最少的路徑。        |
| **Dijkstra** | **非負權重** | $O(E \log V)$ (使用二元堆積) | $O(V)$   | **考試重點 (概念，非程式碼)**。若用斐波那契堆積，最壞情況為 $O(E + V \log V)$。 |
| DAG SP         | 允許負權重 (需為 DAG)     | $O(V+E)$                   | $O(V)$   | 依賴拓撲排序，線性時間。                     |
| Bellman-Ford   | 允許負權重                | $O(VE)$                    | $O(V)$   | 可檢測負權環。相對較慢但通用。               |
| SPFA           | 允許負權重                | $O(VE)$ (最壞). 平均 $O(E)$ 或 $O(E+V)$ | $O(V)$   | Bellman-Ford的佇列優化，實際中常更快，可檢測負權環。 |

---
[[演算法筆記_總覽與考試重點]]
