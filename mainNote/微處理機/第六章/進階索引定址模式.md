# 進階索引定址模式

本節介紹 ARM 處理器中的進階索引定址模式，包括預索引、帶回寫的預索引和後索引等。

## 進階索引定址模式概述

進階索引定址模式是基於暫存器間接定址的擴展，提供了更靈活的記憶體存取方式。這些模式允許在基底暫存器的基礎上加上偏移量，並可選擇是否更新基底暫存器。

## 偏移量類型

在進階索引定址模式中，偏移量可以是以下三種類型之一：

1. **立即偏移 (Immediate Offset)**：
   ```assembly
   LDR R0, [R1, #4]    ; 偏移量是立即數 4
   ```

2. **暫存器偏移 (Register Offset)**：
   ```assembly
   LDR R0, [R1, R2]    ; 偏移量是暫存器 R2 的值
   ```

3. **移位暫存器偏移 (Scaled Register Offset)**：
   ```assembly
   LDR R0, [R1, R2, LSL #2]    ; 偏移量是 R2 左移 2 位的值
   ```

## 預索引 (Pre-indexed)

預索引模式先計算有效位址 (基底暫存器 + 偏移量)，然後使用該位址存取記憶體。基底暫存器的值不變。

```assembly
LDR Rd, [Rn, offset]    ; Rd = Memory[Rn + offset]
```

執行步驟：
1. 計算有效位址 EA = Rn + offset
2. 從 EA 載入資料到 Rd
3. Rn 的值不變

**範例**：
```assembly
    MOV R1, #0x20000000    ; R1 = 0x20000000
    LDR R0, [R1, #4]       ; R0 = Memory[0x20000004]
    ; R1 仍然是 0x20000000
```

## 帶回寫的預索引 (Pre-indexed with Writeback)

帶回寫的預索引模式先計算有效位址，然後使用該位址存取記憶體，最後將有效位址寫回基底暫存器。

```assembly
LDR Rd, [Rn, offset]!    ; Rd = Memory[Rn + offset], Rn = Rn + offset
```

注意 `!` 符號表示回寫。

執行步驟：
1. 計算有效位址 EA = Rn + offset
2. 從 EA 載入資料到 Rd
3. 更新 Rn = EA

**範例**：
```assembly
    MOV R1, #0x20000000    ; R1 = 0x20000000
    LDR R0, [R1, #4]!      ; R0 = Memory[0x20000004], R1 = 0x20000004
```

## 後索引 (Post-indexed)

後索引模式先使用基底暫存器的原始值作為有效位址存取記憶體，然後再更新基底暫存器 (加上偏移量)。

```assembly
LDR Rd, [Rn], offset    ; Rd = Memory[Rn], Rn = Rn + offset
```

執行步驟：
1. 使用 Rn 作為有效位址 EA = Rn
2. 從 EA 載入資料到 Rd
3. 更新 Rn = Rn + offset

**範例**：
```assembly
    MOV R1, #0x20000000    ; R1 = 0x20000000
    LDR R0, [R1], #4       ; R0 = Memory[0x20000000], R1 = 0x20000004
```

## 三種索引模式的比較

假設 R1 = 0x20000000：

| 索引模式 | 指令 | 載入位址 | 執行後 R1 的值 |
|---------|------|---------|--------------|
| 預索引 | `LDR R0, [R1, #4]` | 0x20000004 | 0x20000000 (不變) |
| 帶回寫的預索引 | `LDR R0, [R1, #4]!` | 0x20000004 | 0x20000004 (更新) |
| 後索引 | `LDR R0, [R1], #4` | 0x20000000 | 0x20000004 (更新) |

## 進階索引定址模式的應用

### 陣列存取

```assembly
; 存取整數陣列 (每個元素 4 位元組)
    MOV R0, #0           ; 索引 i = 0
    LDR R1, =array       ; R1 = 陣列基底位址
    
Loop:
    CMP R0, #10          ; 比較 i 和 10
    BGE Done             ; 如果 i >= 10，結束迴圈
    
    LDR R2, [R1, R0, LSL #2]  ; R2 = array[i] (R1 + R0*4)
    ; 處理 R2...
    
    ADD R0, R0, #1       ; i++
    B Loop
    
Done:
```

### 字串處理

```assembly
; 計算字串長度
    LDR R0, =string      ; R0 = 字串位址
    MOV R1, #0           ; R1 = 長度計數器
    
Loop:
    LDRB R2, [R0], #1    ; R2 = *R0++
    CMP R2, #0           ; 檢查是否為 null 終止符
    BEQ Done             ; 如果是，結束迴圈
    
    ADD R1, R1, #1       ; 長度++
    B Loop
    
Done:
    ; R1 包含字串長度
```

### 堆疊操作

```assembly
; 手動實現 PUSH {R0, R1, R2}
    SUB SP, SP, #12      ; 配置 12 位元組 (3 個暫存器 * 4 位元組)
    STR R0, [SP, #8]     ; 儲存 R0
    STR R1, [SP, #4]     ; 儲存 R1
    STR R2, [SP, #0]     ; 儲存 R2
    
; 手動實現 POP {R0, R1, R2}
    LDR R2, [SP, #0]     ; 載入 R2
    LDR R1, [SP, #4]     ; 載入 R1
    LDR R0, [SP, #8]     ; 載入 R0
    ADD SP, SP, #12      ; 釋放 12 位元組
```

### 結構體存取

```assembly
; 假設結構體 struct { int a; int b; int c; }
; R0 包含結構體指標
    LDR R1, [R0, #0]     ; R1 = struct->a (偏移量 0)
    LDR R2, [R0, #4]     ; R2 = struct->b (偏移量 4)
    LDR R3, [R0, #8]     ; R3 = struct->c (偏移量 8)
```

### 多重載入/儲存

ARM 提供了多重載入/儲存指令，可以一次操作多個暫存器：

```assembly
LDMIA R0!, {R1-R3, R12}    ; 從 R0 指向的位址載入到 R1, R2, R3, R12，並更新 R0
STMIA R0!, {R1-R3, R12}    ; 將 R1, R2, R3, R12 儲存到 R0 指向的位址，並更新 R0
```

這些指令使用進階索引定址模式的概念，但有特殊的語法。

## 進階索引定址模式的效率

不同索引模式的效率比較：

1. **預索引**：通常需要額外的內部週期來計算有效位址
2. **帶回寫的預索引**：與預索引類似，但有額外的回寫操作
3. **後索引**：通常與預索引效率相近，但在某些情況下可能更有效率

選擇哪種索引模式主要取決於程式的需求，而非效率差異。

## 返回

- [[ARM定址模式|返回第六章目錄]]
- [[微處理機概述|返回微處理機概述]]
