# 副程式呼叫

本節介紹 ARM 處理器中的副程式 (Subroutine / Function) 呼叫機制，包括分支與連結指令、返回機制以及參數傳遞。

## 副程式概念

副程式是一段可重複使用的程式碼，可以從程式的不同部分呼叫。使用副程式可以：
- 提高程式碼重用性
- 改善程式結構
- 簡化程式設計和維護

## 分支與連結指令

### BL 指令 (Branch with Link)

```assembly
BL label    ; 跳轉到 label，並將返回位址存入 LR
```

BL 指令執行兩個操作：
1. 將下一條指令的位址 (BL 指令的下一條指令位址) 存入連結暫存器 (LR, R14)
2. 跳轉到目標位址 (label)

**特性**：
- 採用 PC 相對定址
- 跳轉範圍約 ±32MB
- 自動保存返回位址到 LR

**範例**：
```assembly
    MOV R0, #5      ; 設置參數
    BL Calculate    ; 呼叫副程式
    ; 返回後繼續執行
    ...

Calculate:
    ; 副程式主體
    ADD R0, R0, R0  ; R0 = R0 * 2
    BX LR           ; 返回呼叫者
```

### BLX 指令 (Branch with Link and Exchange)

```assembly
BLX Rm    ; 跳轉到 Rm 中的位址，並將返回位址存入 LR
```

BLX 指令類似於 BL，但目標位址來自暫存器，並可能切換指令集狀態。

**特性**：
- 可跳轉到 4GB 位址空間中的任意位址
- 自動保存返回位址到 LR
- Rm 的最低位用於切換 ARM/Thumb 狀態 (在 Cortex-M 中固定為 Thumb)

## 返回機制

副程式執行完畢後，需要返回到呼叫點繼續執行。

### BX LR 指令

```assembly
BX LR    ; 跳轉到 LR 中的位址
```

BX LR 指令將 LR 中的返回位址複製到 PC，實現返回。

**範例**：
```assembly
MyFunction:
    ; 副程式主體
    ...
    BX LR    ; 返回呼叫者
```

## 巢狀呼叫

當一個副程式內部再次呼叫其他副程式時，稱為巢狀呼叫。這種情況下，需要保存 LR 的值，否則會丟失外層呼叫的返回位址。

### 使用堆疊保存 LR

```assembly
Function1:
    PUSH {LR}       ; 保存返回位址
    BL Function2    ; 呼叫另一個副程式
    ; 返回後繼續執行
    ...
    POP {PC}        ; 恢復返回位址並返回 (直接載入到 PC)
    
Function2:
    ; 副程式主體
    ...
    BX LR           ; 返回 Function1
```

### 保存多個暫存器

通常需要同時保存 LR 和其他被呼叫者保存的暫存器：

```assembly
Function:
    PUSH {R4-R7, LR}    ; 保存被呼叫者保存的暫存器和返回位址
    
    ; 副程式主體，可以自由使用 R4-R7
    ...
    
    POP {R4-R7, PC}     ; 恢復暫存器並返回
```

## 副程式標記

使用 `PROC` 和 `ENDP` 指令可以更清晰地標示副程式的開始和結束：

```assembly
MyFunction PROC
    PUSH {R4-R7, LR}
    
    ; 副程式主體
    ...
    
    POP {R4-R7, PC}
    ENDP
```

## 參數傳遞與暫存器使用規範

ARM 架構過程呼叫標準 (AAPCS, ARM Architecture Procedure Call Standard) 定義了參數傳遞和暫存器使用的規則：

### 參數傳遞

- **R0-R3**：用於傳遞前 4 個參數
- **堆疊**：額外的參數通過堆疊傳遞

### 返回值

- **R0**：用於傳遞返回值 (如果是 64 位元值，則使用 R0 和 R1)

### 暫存器保存責任

- **R0-R3, R12**：呼叫者保存 (Caller-saved)
  - 副程式可以自由修改這些暫存器
  - 呼叫者如果需要保留這些暫存器的值，必須在呼叫前保存
  
- **R4-R11**：被呼叫者保存 (Callee-saved)
  - 副程式如果需要使用這些暫存器，必須先保存原值，返回前恢復
  - 呼叫者可以假設這些暫存器的值在呼叫後不變

- **R13 (SP)**：堆疊指標，必須在返回前恢復原值
- **R14 (LR)**：連結暫存器，包含返回位址
- **R15 (PC)**：程式計數器

## 參數傳遞範例

### 簡單參數傳遞

```assembly
; 呼叫 Add 函式，計算 R0 = 5 + 3
    MOV R0, #5      ; 第一個參數
    MOV R1, #3      ; 第二個參數
    BL Add          ; 呼叫 Add 函式
    ; 返回後 R0 包含結果 (8)
    ...

Add:
    ADD R0, R0, R1  ; R0 = R0 + R1
    BX LR           ; 返回
```

### 多參數傳遞

```assembly
; 呼叫 Calculate 函式，計算 R0 = (a * b) + (c * d)
    MOV R0, #2      ; 參數 a
    MOV R1, #3      ; 參數 b
    MOV R2, #4      ; 參數 c
    MOV R3, #5      ; 參數 d
    BL Calculate    ; 呼叫 Calculate 函式
    ; 返回後 R0 包含結果 (26)
    ...

Calculate:
    PUSH {R4, LR}   ; 保存 R4 和返回位址
    
    MUL R4, R0, R1  ; R4 = a * b
    MUL R0, R2, R3  ; R0 = c * d
    ADD R0, R0, R4  ; R0 = (a * b) + (c * d)
    
    POP {R4, PC}    ; 恢復 R4 並返回
```

## 遞迴呼叫

遞迴是一種特殊的巢狀呼叫，其中函式直接或間接地呼叫自己。

```assembly
; 計算階乘：Factorial(n) = n * Factorial(n-1)，Factorial(0) = 1
Factorial:
    PUSH {R4, LR}   ; 保存 R4 和返回位址
    
    MOV R4, R0      ; 保存 n
    CMP R0, #0      ; 檢查 n 是否為 0
    BNE Recurse     ; 如果 n != 0，遞迴呼叫
    
    ; 基本情況：n = 0
    MOV R0, #1      ; 返回 1
    POP {R4, PC}    ; 恢復 R4 並返回
    
Recurse:
    SUB R0, R0, #1  ; R0 = n - 1
    BL Factorial    ; 遞迴呼叫 Factorial(n-1)
    MUL R0, R4, R0  ; R0 = n * Factorial(n-1)
    POP {R4, PC}    ; 恢復 R4 並返回
```

## 返回

- [[ARM分支呼叫與迴圈|返回第四章目錄]]
- [[微處理機概述|返回微處理機概述]]
