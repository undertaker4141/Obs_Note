# 載入/儲存指令

## ARM 的 Load/Store 架構

ARM 是一種 Load/Store 架構的處理器，這意味著：

1. 只有載入/儲存指令 (LDR/STR) 能存取記憶體
2. 資料處理指令 (如 ADD, SUB, MOV) 只能操作暫存器中的資料
3. 要處理記憶體中的資料，必須先載入到暫存器，處理後再儲存回記憶體

這種設計簡化了指令集，並提高了處理器效能。

## 基本載入/儲存指令

### 載入指令 (Load)

```assembly
LDR Rd, [Rx]   ; 將記憶體位址 Rx 中的 32 位元資料載入到 Rd
```

其中：
- `Rd` 是目的暫存器
- `Rx` 是包含記憶體位址的暫存器
- 方括號 `[ ]` 表示間接定址 (取 Rx 中的值作為位址)

### 儲存指令 (Store)

```assembly
STR Rx, [Rd]   ; 將 Rx 中的 32 位元資料儲存到記憶體位址 Rd
```

注意：在 STR 指令中，來源暫存器在前，目的位址在後。

## 處理不同大小的資料

ARM 提供了不同的指令來處理不同大小的資料：

### 位元組操作 (8 位元)

```assembly
LDRB Rd, [Rx]   ; 載入位元組，高位補零
STRB Rx, [Rd]   ; 儲存位元組 (只儲存 Rx 的低 8 位)
```

### 半字操作 (16 位元)

```assembly
LDRH Rd, [Rx]   ; 載入半字，高位補零
STRH Rx, [Rd]   ; 儲存半字 (只儲存 Rx 的低 16 位)
```

## 有號數載入

對於有號數，ARM 提供了符號擴展載入指令：

```assembly
LDRSB Rd, [Rx]   ; 載入有號位元組，將 bit 7 複製到高 24 位
LDRSH Rd, [Rx]   ; 載入有號半字，將 bit 15 複製到高 16 位
```

這些指令確保負數在載入後仍然保持正確的值。

## 多重載入/儲存

ARM 提供了多重載入/儲存指令，可以一次操作多個暫存器：

```assembly
LDMIA Rx!, {R0-R3}   ; 載入 4 個連續字到 R0-R3，並更新 Rx
STMIA Rx!, {R0-R3}   ; 儲存 R0-R3 到連續記憶體，並更新 Rx
```

其中：
- `IA` 表示 Increment After (每次傳輸後增加位址)
- `!` 表示更新基底暫存器 (Rx)
- 大括號 `{ }` 中列出要傳輸的暫存器

其他變體包括：
- `LDMIB/STMIB`：Increment Before
- `LDMDA/STMDA`：Decrement After
- `LDMDB/STMDB`：Decrement Before

## 堆疊操作

堆疊操作是多重載入/儲存的特殊情況：

```assembly
PUSH {R0-R3, LR}   ; 將 R0-R3 和 LR 推入堆疊
POP {R0-R3, PC}    ; 從堆疊彈出到 R0-R3 和 PC
```

這些是偽指令，實際上會被轉換為：
- `PUSH {Rx}` → `STMDB SP!, {Rx}`
- `POP {Rx}` → `LDMIA SP!, {Rx}`

## 記憶體存取範例

### 基本載入/儲存

```assembly
; 讀取記憶體位址 0x20000000 的值到 R0
LDR R1, =0x20000000   ; 將位址載入 R1
LDR R0, [R1]          ; 讀取 [R1] 的值到 R0

; 將 R0 的值寫入記憶體位址 0x20000004
LDR R1, =0x20000004   ; 將位址載入 R1
STR R0, [R1]          ; 將 R0 的值寫入 [R1]
```

### 陣列存取

```assembly
; 假設 R0 包含陣列基底位址，R1 是索引
LDR R2, [R0, R1, LSL #2]   ; 載入 R0 + R1*4 位址的值到 R2
                           ; (假設陣列元素為 32 位元)
```

### 結構體存取

```assembly
; 假設 R0 包含結構體基底位址
LDR R1, [R0, #0]    ; 載入第一個欄位 (偏移量 0)
LDR R2, [R0, #4]    ; 載入第二個欄位 (偏移量 4)
LDR R3, [R0, #8]    ; 載入第三個欄位 (偏移量 8)
```

## 返回

- [[ARM架構與組合語言程式設計|返回第二章目錄]]
- [[微處理機概述|返回微處理機概述]]
