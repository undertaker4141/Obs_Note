---
banner: 模板/banner.jpg
banner_y: "86.5"
---
# 演算法筆記 第 7 講：計數排序 (Counting Sort)

[[演算法筆記_總覽與考試重點]]

## 排序演算法的複雜度下限

### 基於比較模型的排序 (Comparison-based Sorting)

-   **決策樹模型 (Decision Tree Model):**
    -   任何基於比較的排序演算法都可以被抽象成一個決策樹。
    -   樹的每個內部節點代表一次元素間的比較。
    -   樹的每個葉節點代表一種可能的排序結果 (元素的排列)。
    -   對於 $N$ 個不同的元素，有 $N!$ 種可能的排列。因此，決策樹至少有 $N!$ 個葉節點。
    -   樹的高度 $h$ 代表了最壞情況下的比較次數。
-   **下限證明:**
    -   一個高度為 $h$ 的二元樹最多有 $2^h$ 個葉節點。
    -   所以，$2^h \ge N!$。
    -   取對數，$h \ge \log_2(N!)$。
    -   根據斯特林公式 (Stirling's approximation)，$\log(N!) \approx N \log N - N \log e + O(\log N)$。
    -   因此，$h = \Omega(N \log N)$。
    -   這意味著任何基於比較的排序演算法，在最壞情況下至少需要 $\Omega(N \log N)$ 次比較。
    -   合併排序 (Mergesort) 和堆積排序 (Heapsort) 都是漸進最優的比較排序演算法，它們的時間複雜度為 $\Theta(N \log N)$。

## 計數排序 (Counting Sort) [[演算法筆記_總覽與考試重點]]

計數排序是一種**非比較排序**演算法，它不依賴元素間的比較來確定順序。因此，它可以突破 $\Omega(N \log N)$ 的下限。

### 核心思想與假設

-   **假設:** 輸入的 $N$ 個元素是來自一個已知範圍 $[0, R-1]$ (或更一般地，$[k, k+R-1]$) 的整數。其中 $R$ 是鍵的範圍大小。
-   **核心思想:**
    1.  計算每個鍵值出現的頻率。
    2.  利用頻率計算出每個鍵值在排序後陣列中的起始位置。
    3.  將元素直接放置到它們排序後的位置。

### 演算法步驟

假設輸入陣列為 `a[]`，長度為 `N`，鍵的範圍是 `0` 到 `R-1`。

1.  **計算頻率 (Count Frequencies):**
    -   創建一個大小為 `R` (或 `R+1`，取決於如何處理索引) 的計數陣列 `count[]`，並初始化所有元素為 0。
    -   遍歷輸入陣列 `a[]`，對於每個元素 `x`，增加 `count[x]` 的值。
    -   `count[k]` 現在儲存了鍵值 `k` 在輸入中出現的次數。
    ```java
    // 假設鍵值範圍是 0 到 R-1
    // count 陣列大小為 R，索引 0 到 R-1
    // 或者，如下面範例，count 陣列大小為 R+1，索引 0 到 R，其中 count[0] 可能不用或有特殊意義
    // 這裡的範例來自講義，count[key+1]++，所以 count[0] 用於計算 key=0 之前有多少元素 (即0個)
    // count[r] 最終會是小於 r 的鍵的數量
    int[] count = new int[R + 1];
    for (int i = 0; i < N; i++) {
        count[a[i] + 1]++; // a[i] 是鍵值
    }
    ```

2.  **計算累積頻率 (Compute Cumulates / Starting Positions):**
    -   修改 `count[]` 陣列，使得 `count[r]` 儲存的是小於鍵值 `r` 的元素總數。這可以通過累加實現。
    -   `count[r]` 現在代表了鍵值 `r` 在排序後陣列中的起始索引。
    ```java
    // count[r] 將會是鍵值 r 的起始索引
    for (int r = 0; r < R; r++) { // 注意這裡的迴圈邊界
        count[r+1] += count[r];
    }
    // 現在 count[0] = 0 (小於0的鍵的數量)
    // count[1] = 鍵0的數量 (鍵1的起始索引)
    // count[r] = 鍵 r 的起始索引
    // count[R] = 總元素數量 N
    ```

3.  **移動元素 (Move Items / Distribute):**
    -   創建一個輔助陣列 `aux[]`，大小為 `N`，用於儲存排序後的結果。
    -   遍歷原始輸入陣列 `a[]`。對於每個元素 `a[i]`：
        -   將 `a[i]` 放置到 `aux[count[a[i]]]`。
        -   然後增加 `count[a[i]]` 的值，以便下一個具有相同鍵值的元素能被放置在正確的下一個位置 (這確保了穩定性)。
    ```java
    Comparable[] aux = new Comparable[N]; // 或具體類型
    for (int i = 0; i < N; i++) {
        aux[count[a[i]]++] = a[i]; // 將 a[i] 放到它在 aux 中的正確位置，然後增加 count[a[i]]
    }
    ```

4.  **複製回原陣列 (Copy Back):**
    -   將輔助陣列 `aux[]` 中的元素複製回原始陣列 `a[]`。
    ```java
    for (int i = 0; i < N; i++) {
        a[i] = aux[i];
    }
    ```

### 範例 (來自講義)

輸入 `a[] = {d, a, c, f, f, b, d, b, f, b, e, a}` (假設 a=0, b=1, ..., f=5)，$N=12, R=6$。

1.  **計算頻率 `count[key+1]++`:**
    `count` 陣列 (大小 $R+1 = 7$)
    -   `a` (0): 2次 $\rightarrow$ `count[1]` 增加 2
    -   `b` (1): 3次 $\rightarrow$ `count[2]` 增加 3
    -   `c` (2): 1次 $\rightarrow$ `count[3]` 增加 1
    -   `d` (3): 2次 $\rightarrow$ `count[4]` 增加 2
    -   `e` (4): 1次 $\rightarrow$ `count[5]` 增加 1
    -   `f` (5): 3次 $\rightarrow$ `count[6]` 增加 3
    初始 `count` (在 `count[a[i]+1]++` 之後):
    `[0, 2, 3, 1, 2, 1, 3]` (索引 0 到 6)

2.  **計算累積頻率 `count[r+1] += count[r]`:**
    -   `count[0] = 0`
    -   `count[1] = count[1] + count[0] = 2 + 0 = 2` (鍵0的數量，也是鍵1的起始索引)
    -   `count[2] = count[2] + count[1] = 3 + 2 = 5` (鍵0和1的數量，也是鍵2的起始索引)
    -   `count[3] = count[3] + count[2] = 1 + 5 = 6`
    -   `count[4] = count[4] + count[3] = 2 + 6 = 8`
    -   `count[5] = count[5] + count[4] = 1 + 8 = 9`
    -   `count[6] = count[6] + count[5] = 3 + 9 = 12`
    最終 `count` (代表起始索引):
    `[0, 2, 5, 6, 8, 9, 12]`
    -   `count[0]` (鍵 `a` 的起始索引) = 0
    -   `count[1]` (鍵 `b` 的起始索引) = 2
    -   `count[2]` (鍵 `c` 的起始索引) = 5
    -   `count[3]` (鍵 `d` 的起始索引) = 6
    -   `count[4]` (鍵 `e` 的起始索引) = 8
    -   `count[5]` (鍵 `f` 的起始索引) = 9

3.  **移動元素 `aux[count[a[i]]++] = a[i]`:**
    -   `a[0]=d` (3): `aux[count[3]++] = d` $\rightarrow$ `aux[6]=d`, `count[3]=7`
    -   `a[1]=a` (0): `aux[count[0]++] = a` $\rightarrow$ `aux[0]=a`, `count[0]=1`
    -   `a[2]=c` (2): `aux[count[2]++] = c` $\rightarrow$ `aux[5]=c`, `count[2]=6`
    -   ... 以此類推
    最終 `aux[] = {a, a, b, b, b, c, d, d, e, f, f, f}`

4.  **複製回原陣列。**

### 效能分析

-   **時間複雜度:**
    -   步驟 1 (計算頻率): $\Theta(N)$
    -   步驟 2 (計算累積頻率): $\Theta(R)$
    -   步驟 3 (移動元素): $\Theta(N)$
    -   步驟 4 (複製回來): $\Theta(N)$
    -   總時間複雜度: $\Theta(N+R)$。
    -   如果 $R$ 是 $O(N)$ (例如，鍵的範圍與元素數量在同一個數量級)，則時間複雜度為 $\Theta(N)$。
-   **空間複雜度:**
    -   `count[]` 陣列: $\Theta(R)$
    -   `aux[]` 陣列: $\Theta(N)$
    -   總空間複雜度: $\Theta(N+R)$。
-   **穩定性 (Stability):**
    -   計數排序是**穩定**的。在移動元素步驟中，如果從頭到尾遍歷原始陣列，並使用 `count[key]++` 的方式來確定位置，那麼具有相同鍵值的元素在排序後的陣列中將保持它們在原始陣列中的相對順序。講義中的範例實現了這一點。

### 應用

-   當鍵是小範圍內的整數時非常有效。
-   可以作為其他排序演算法 (如基數排序 Radix Sort) 的子程序。
-   排序學生記錄 (例如，按組別排序，其中組別是小整數)。

### 與比較排序的比較

-   計數排序不是基於比較的，因此不受 $\Omega(N \log N)$ 下限的限制。
-   當 $R$ 遠大於 $N$ (例如 $R = N^2$ 或更大) 時，計數排序的效能會變差 ($\Theta(N+R)$ 可能比 $\Theta(N \log N)$ 差)，並且空間需求也會很大。
-   對於鍵的範圍遠大於元素數量的情況，比較排序 (如合併排序、快速排序) 通常更優。

## 基數排序 (Radix Sort) - 簡介

計數排序的一個重要應用是作為基數排序的子程序。

### LSD (Least Significant Digit First) 基數排序

-   **思想:** 從鍵的最低有效位 (Least Significant Digit) 開始，逐位向最高有效位 (Most Significant Digit) 排序。
-   **步驟:** 對於固定長度為 $W$ 的字串 (或數字，可以看作是 $W$ 位數)：
    1.  從第 $d = W-1$ 位 (最低位) 到第 $d = 0$ 位 (最高位) 進行迭代。
    2.  在每次迭代中，使用**穩定**的排序演算法 (如計數排序) 根據當前第 $d$ 位的字元 (或數字位) 對所有元素進行排序。
-   **正確性:** 依賴於所使用的子排序演算法的穩定性。歸納證明：在第 $i$ 輪之後，所有字串都已根據它們的最後 $i$ 個字元正確排序。當處理更高位時，如果高位相等，穩定性確保了之前低位已建立的順序得以保留。
-   **效能 (使用計數排序作為子程序):**
    -   假設字元集大小為 $R$ (例如 ASCII 為 256)。
    -   每一輪計數排序的時間是 $\Theta(N+R)$。
    -   總共 $W$ 輪。
    -   總時間複雜度: $\Theta(W(N+R))$。
    -   如果 $W$ 是常數，且 $R$ 是 $O(N)$ 或更小，則 LSD 基數排序可以是線性的 $\Theta(N)$。

### MSD (Most Significant Digit First) 基數排序

-   **思想:** 從鍵的最高有效位開始，遞迴地對子組進行排序。
    1.  根據第一個字元將陣列劃分成 $R$ 個桶 (使用鍵索引計數)。
    2.  遞迴地對每個桶中的字串 (忽略第一個字元) 進行排序。
-   **效能:**
    -   最壞情況: $\Theta(W(N+R))$ (例如，所有字串都相同，或前綴很長)。
    -   平均情況 (隨機字串): $\Theta(N \log_R N)$ 或 $\Theta(NW)$ (取決於實現和字串特性)。
    -   對於小字串陣列的處理需要優化 (例如，切換到插入排序)。

計數排序是實現高效基數排序的關鍵。