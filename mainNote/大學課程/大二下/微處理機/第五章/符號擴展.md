# 符號擴展

本節介紹符號擴展 (Sign Extension) 的概念和實現方法，包括 ARM 處理器中的符號擴展載入指令。

## 符號擴展的概念

符號擴展是將較小位元寬度的有號數擴展為較大位元寬度的過程，同時保持其數值不變。這是通過將原始數值的符號位 (最高位) 複製到所有新增的高位來實現的。

例如，將 8 位元有號數 `10000101` (-123) 擴展為 32 位元：
- 結果為 `11111111 11111111 11111111 10000101`

## 符號擴展的必要性

在 ARM 處理器中，符號擴展主要用於以下情況：

### 1. 載入較小的有號數

當使用 `LDRB` 或 `LDRH` 指令載入 8 位元或 16 位元有號數時，預設情況下高位會補 0，這會破壞負數的值：

```assembly
    ; 假設記憶體位址 [R0] 包含 8 位元有號數 0x85 (-123)
    LDRB R1, [R0]    ; R1 = 0x00000085 (133)，而非 -123
```

這裡，負數 -123 被錯誤地解釋為正數 133，因為高位被補 0 而非符號擴展。

### 2. 運算前的類型轉換

在進行混合寬度的運算前，需要將較小的有號數擴展為較大的寬度，以避免錯誤的結果：

```assembly
    ; 不正確的方式
    MOV R0, #0xFF    ; R0 = 0x000000FF (255)，但應該是 -1
    ADD R1, R0, #1   ; R1 = 0x00000100 (256)，而非 0
    
    ; 正確的方式 (使用符號擴展)
    MOV R0, #0xFF    ; R0 = 0x000000FF (255)
    SXTB R0, R0      ; 符號擴展位元組，R0 = 0xFFFFFFFF (-1)
    ADD R1, R0, #1   ; R1 = 0x00000000 (0)
```

## ARM 中的符號擴展載入指令

ARM 提供了專門的符號擴展載入指令，用於從記憶體載入較小的有號數並自動進行符號擴展：

### LDRSB (Load Register Signed Byte)

```assembly
LDRSB Rd, [Rn]    ; 載入有號位元組，將 bit 7 複製到高 24 位
```

LDRSB 指令從記憶體位址 `Rn` 載入一個 8 位元有號數，並將其符號位 (bit 7) 複製到結果的高 24 位，然後存入 `Rd`。

**範例**：
```assembly
    ; 假設記憶體位址 [R0] 包含 8 位元有號數 0x85 (-123)
    LDRSB R1, [R0]    ; R1 = 0xFFFFFF85 (-123)
```

### LDRSH (Load Register Signed Half-word)

```assembly
LDRSH Rd, [Rn]    ; 載入有號半字，將 bit 15 複製到高 16 位
```

LDRSH 指令從記憶體位址 `Rn` 載入一個 16 位元有號數，並將其符號位 (bit 15) 複製到結果的高 16 位，然後存入 `Rd`。

**範例**：
```assembly
    ; 假設記憶體位址 [R0] 包含 16 位元有號數 0x8001 (-32767)
    LDRSH R1, [R0]    ; R1 = 0xFFFF8001 (-32767)
```

## ARM 中的符號擴展指令

除了載入指令外，ARM 還提供了直接對暫存器中的值進行符號擴展的指令：

### SXTB (Sign Extend Byte)

```assembly
SXTB Rd, Rm    ; 將 Rm 的低 8 位符號擴展到 32 位
```

SXTB 指令將 `Rm` 的低 8 位作為有號數，並將其符號位 (bit 7) 複製到結果的高 24 位，然後存入 `Rd`。

**範例**：
```assembly
    MOV R0, #0x85    ; R0 = 0x00000085 (133)
    SXTB R1, R0      ; R1 = 0xFFFFFF85 (-123)
```

### SXTH (Sign Extend Half-word)

```assembly
SXTH Rd, Rm    ; 將 Rm 的低 16 位符號擴展到 32 位
```

SXTH 指令將 `Rm` 的低 16 位作為有號數，並將其符號位 (bit 15) 複製到結果的高 16 位，然後存入 `Rd`。

**範例**：
```assembly
    MOV R0, #0x8001    ; R0 = 0x00008001 (32769)
    SXTH R1, R0        ; R1 = 0xFFFF8001 (-32767)
```

## 手動實現符號擴展

在不支援上述指令的 ARM 核心中，可以手動實現符號擴展：

### 位元組符號擴展

```assembly
    ; 將 R0 的低 8 位符號擴展到 32 位
    LSL R0, R0, #24    ; 左移 24 位，將低 8 位移到高 8 位
    ASR R0, R0, #24    ; 算術右移 24 位，符號位填充高位
```

### 半字符號擴展

```assembly
    ; 將 R0 的低 16 位符號擴展到 32 位
    LSL R0, R0, #16    ; 左移 16 位，將低 16 位移到高 16 位
    ASR R0, R0, #16    ; 算術右移 16 位，符號位填充高位
```

## 符號擴展的應用

### 混合寬度運算

```assembly
    ; 計算 8 位元有號數和 32 位元有號數的和
    LDRSB R0, [R1]     ; 載入 8 位元有號數並符號擴展
    ADD R0, R0, R2     ; 與 32 位元數相加
```

### 陣列元素存取

```assembly
    ; 存取有號位元組陣列
    LDRSB R0, [R1, R2]    ; 載入 R1+R2 位址的有號位元組
```

### 類型轉換

```assembly
    ; 將 16 位元有號數轉換為 32 位元
    LDRSH R0, [R1]     ; 載入 16 位元有號數並符號擴展
    ; 現在 R0 包含 32 位元有號數
```

## 符號擴展與零擴展的比較

- **符號擴展 (Sign Extension)**：
  - 將符號位複製到所有高位
  - 用於有號數
  - 保持數值的符號和大小

- **零擴展 (Zero Extension)**：
  - 高位補 0
  - 用於無號數
  - 由 LDRB, LDRH 等指令預設執行

**範例**：
```assembly
    ; 假設記憶體位址 [R0] 包含 0x85
    
    ; 符號擴展 (視為有號數 -123)
    LDRSB R1, [R0]    ; R1 = 0xFFFFFF85 (-123)
    
    ; 零擴展 (視為無號數 133)
    LDRB R2, [R0]     ; R2 = 0x00000085 (133)
```

## 返回

- [[ARM有號整數運算|返回第五章目錄]]
- [[微處理機概述|返回微處理機概述]]
