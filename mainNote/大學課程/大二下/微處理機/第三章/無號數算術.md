# 無號數算術

本節介紹 ARM 處理器中的無號數算術指令，包括加法、減法、乘法和除法。

## 加法指令

ARM 提供了多種加法指令，用於不同的加法操作：

### 基本加法

```assembly
ADD Rd, Rn, Op2    ; Rd = Rn + Op2
```

其中 `Op2` 可以是暫存器或立即值。

**範例**：
```assembly
ADD R0, R1, R2     ; R0 = R1 + R2
ADD R3, R3, #1     ; R3 = R3 + 1 (遞增 R3)
```

### 帶旗標更新的加法

```assembly
ADDS Rd, Rn, Op2   ; Rd = Rn + Op2，並更新旗標
```

此指令會更新 CPSR 中的 N, Z, C, V 旗標：
- N：如果結果為負數 (最高位為 1)
- Z：如果結果為零
- C：如果產生進位
- V：如果有號數溢位

### 帶進位加法

```assembly
ADC Rd, Rn, Op2    ; Rd = Rn + Op2 + C
ADCS Rd, Rn, Op2   ; 同上，並更新旗標
```

這些指令將 CPSR 中的 C 旗標作為額外的輸入，用於多字組加法。

### 多字組加法範例

以下範例展示如何執行 64 位元加法 (R1:R0 + R3:R2)：

```assembly
ADDS R0, R0, R2    ; 加低 32 位，並更新旗標
ADC  R1, R1, R3    ; 加高 32 位，加上可能的進位
```

## 減法指令

ARM 處理器內部使用 2's 補數執行減法操作。

### 基本減法

```assembly
SUB Rd, Rn, Op2    ; Rd = Rn - Op2
```

**範例**：
```assembly
SUB R0, R1, R2     ; R0 = R1 - R2
SUB R3, R3, #1     ; R3 = R3 - 1 (遞減 R3)
```

### 帶旗標更新的減法

```assembly
SUBS Rd, Rn, Op2   ; Rd = Rn - Op2，並更新旗標
```

此指令會更新 CPSR 中的 N, Z, C, V 旗標：
- C 旗標在減法中表示「無借位」，即 Rn ≥ Op2 時 C=1

### 帶借位減法

```assembly
SBC Rd, Rn, Op2    ; Rd = Rn - Op2 - !C
SBCS Rd, Rn, Op2   ; 同上，並更新旗標
```

這些指令使用 CPSR 中的 C 旗標的反值作為借位，用於多字組減法。

### 反向減法

```assembly
RSB Rd, Rn, Op2    ; Rd = Op2 - Rn
RSBS Rd, Rn, Op2   ; 同上，並更新旗標
```

反向減法 (Reverse Subtract) 交換了減法的操作數順序。

### 多字組減法範例

以下範例展示如何執行 64 位元減法 (R1:R0 - R3:R2)：

```assembly
SUBS R0, R0, R2    ; 減低 32 位，並更新旗標
SBC  R1, R1, R3    ; 減高 32 位，減去可能的借位
```

## 無號數乘法

ARM 提供了多種乘法指令，用於不同的乘法操作：

### 基本乘法

```assembly
MUL Rd, Rn, Rm     ; Rd = Rn * Rm (低 32 位)
MULS Rd, Rn, Rm    ; 同上，並更新旗標 (N, Z)
```

基本乘法指令執行 32x32 → 32 位元乘法，只保留結果的低 32 位。

### 64 位元乘法

```assembly
UMULL RdLo, RdHi, Rn, Rm    ; {RdHi,RdLo} = Rn * Rm (無號數)
UMULLS RdLo, RdHi, Rn, Rm   ; 同上，並更新旗標
```

這些指令執行 32x32 → 64 位元無號數乘法，結果的低 32 位存入 RdLo，高 32 位存入 RdHi。

### 乘加指令

```assembly
MLA Rd, Rn, Rm, Ra    ; Rd = Rn * Rm + Ra
MLAS Rd, Rn, Rm, Ra   ; 同上，並更新旗標
```

乘加指令 (Multiply-Accumulate) 執行乘法後再加上第三個操作數。

### 64 位元乘加

```assembly
UMLAL RdLo, RdHi, Rn, Rm    ; {RdHi,RdLo} = {RdHi,RdLo} + Rn * Rm
UMLALS RdLo, RdHi, Rn, Rm   ; 同上，並更新旗標
```

這些指令將 32x32 位元乘法結果加到 64 位元累加器 {RdHi,RdLo} 中。

## 無號數除法

某些 ARM 核心 (如 Cortex-M3/M4) 支援硬體除法指令：

```assembly
UDIV Rd, Rn, Rm    ; Rd = Rn / Rm (無號數)
```

對於不支援硬體除法的核心，可以使用軟體實現：

### 重複減法實現除法

以下是使用重複減法實現無號數除法的演算法：

```assembly
; R0 = R0 / R1，商存入 R0，餘數存入 R2
    MOV R2, #0         ; 初始化餘數為 0
    MOV R3, #0         ; 初始化商為 0
    
DivLoop:
    CMP R0, R1         ; 比較被除數和除數
    BLO DivDone        ; 如果被除數 < 除數，結束
    
    SUB R0, R0, R1     ; 被除數 = 被除數 - 除數
    ADD R3, R3, #1     ; 商 = 商 + 1
    B DivLoop          ; 繼續迴圈
    
DivDone:
    MOV R2, R0         ; 餘數 = 最終被除數
    MOV R0, R3         ; 商 = 累積的商
```

這種方法效率較低，但在不支援硬體除法的處理器上是必要的。

## 無號數比較

ARM 提供了比較指令，用於無號數比較：

```assembly
CMP Rn, Op2    ; 比較 Rn 和 Op2 (Rn - Op2)，只更新旗標
```

比較後可以使用以下條件碼進行條件執行或分支：

- **EQ** (Equal)：Z=1，相等
- **NE** (Not Equal)：Z=0，不相等
- **CS/HS** (Carry Set/Higher or Same)：C=1，無借位/大於等於
- **CC/LO** (Carry Clear/Lower)：C=0，有借位/小於
- **HI** (Higher)：C=1 且 Z=0，大於
- **LS** (Lower or Same)：C=0 或 Z=1，小於等於

**範例**：
```assembly
CMP R0, R1         ; 比較 R0 和 R1
BHS GreaterOrEqual ; 如果 R0 >= R1，跳轉到 GreaterOrEqual
BLO Less           ; 如果 R0 < R1，跳轉到 Less
```

## 返回

- [[ARM算術與邏輯指令|返回第三章目錄]]
- [[微處理機概述|返回微處理機概述]]
