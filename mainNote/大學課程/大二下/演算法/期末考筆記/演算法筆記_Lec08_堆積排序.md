---
banner: 模板/banner.jpg
banner_y: "87"
---
# 演算法筆記 第 8 講：堆積排序 (Heapsort)

[[演算法筆記_總覽與考試重點]]

## 優先佇列 (Priority Queue) 與 Top-M 問題

### Top-M 問題

-   **問題描述:** 在一個包含 $N$ 個項目 (item) 的資料流 (stream) 中，找出最大的 $M$ 個項目。
-   **應用場景:**
    -   金融詐欺偵測：找出金額最高的交易。
    -   網路監控：標記最可疑的文件或網路流量。
-   **限制:** $N$ 可能非常大，無法將所有項目都存儲在記憶體中。$M$ 也可能很大。

### 使用優先佇列解決 Top-M 問題

-   可以使用一個**最小優先佇列 (Min Priority Queue)** 來解決此問題，佇列的大小維持在 $M$。
-   **演算法:**
    1.  建立一個最小優先佇列 `pq`。
    2.  對於資料流中的每一個項目 `item`：
        a.  將 `item` 插入 `pq`。
        b.  如果 `pq` 的大小超過 $M$，則移除 `pq` 中的最小元素 (`delMin`)。
    3.  處理完所有 $N$ 個項目後，`pq` 中剩下的 $M$ 個項目即為最大的 $M$ 個項目。
-   **成本分析 (使用二元堆積實現的最小優先佇列):**
    -   插入操作: $O(\log M)$
    -   刪除最小操作: $O(\log M)$
    -   總時間複雜度: $N$ 個項目，每個項目最多一次插入和一次刪除，所以是 $O(N \log M)$。
    -   空間複雜度: $O(M)$，用於存儲優先佇列中的元素。

## 二元堆積 (Binary Heap)

二元堆積是一種樹狀資料結構，滿足特定的堆積性質。它通常用陣列來高效實現。

### 定義與性質

1.  **二元樹 (Binary Tree):** 每個節點最多有兩個子節點（左子節點和右子節點）。
2.  **完全二元樹 (Complete Binary Tree):**
    -   樹的每一層都是完全填滿的，除了可能的最後一層。
    -   最後一層的節點都盡可能地靠左排列。
    -   高度為 $h$ 的完全二元樹，節點數 $N$ 介於 $2^h$ 和 $2^{h+1}-1$ 之間。高度約為 $\log N$。
3.  **堆積順序性質 (Heap-ordered Property):**
    -   **最大堆積 (Max-heap):** 每個節點的鍵 (key) 都大於或等於其子節點的鍵。因此，根節點的鍵是堆積中最大的。
    -   **最小堆積 (Min-heap):** 每個節點的鍵都小於或等於其子節點的鍵。因此，根節點的鍵是堆積中最小的。
    (本筆記主要討論最大堆積，用於堆積排序和移除最大元素)。

### 陣列表示法 (Array Representation)

-   將一個完全二元樹的節點按照**層序遍歷 (level order)** 存儲到一個陣列中。
-   為了方便計算父子關係，通常**從索引 1 開始**存儲節點 (索引 0 不使用或有特殊用途)。
-   對於陣列中索引為 `k` 的節點：
    -   其父節點的索引為 $\lfloor k/2 \rfloor$。
    -   其左子節點的索引為 $2k$。
    -   其右子節點的索引為 $2k+1$。
-   這種表示法不需要顯式的指標來維護樹結構。

### 基本操作

#### 1. 上浮 (Swim / Promotion)

-   **情境:** 當一個子節點的鍵變得比其父節點的鍵更大時 (在最大堆積中)，違反了堆積順序。
-   **操作:**
    1.  交換該子節點與其父節點的鍵。
    2.  重複此過程，將該節點不斷向上移動 (上浮)，直到它的鍵小於或等於其新的父節點的鍵，或者它到達根節點。
-   **Java 虛擬碼 (最大堆積):**
    ```java
    private void swim(int k) {
        while (k > 1 && less(k/2, k)) { // k/2 是父節點, k 是當前節點
            exch(k/2, k);
            k = k/2; // 移動到父節點位置繼續檢查
        }
    }
    // less(i, j) 比較 pq[i] 和 pq[j] 的鍵，如果 pq[i] < pq[j] 則返回 true
    // exch(i, j) 交換 pq[i] 和 pq[j]
    ```
-   **成本:** 最多 $\log N$ 次比較和交換 (樹的高度)。

#### 2. 下沉 (Sink / Demotion)

-   **情境:** 當一個父節點的鍵變得比其一個或兩個子節點的鍵更小時 (在最大堆積中)，違反了堆積順序。
-   **操作:**
    1.  找出該父節點的較大的子節點。
    2.  如果父節點的鍵小於這個較大子節點的鍵，則交換它們。
    3.  重複此過程，將該節點不斷向下移動 (下沉)，直到它的鍵大於或等於其所有子節點的鍵，或者它成為葉節點。
-   **Java 虛擬碼 (最大堆積):**
    ```java
    private void sink(int k, int N) { // N 是堆積當前有效大小
        while (2*k <= N) { // 只要 k 還有子節點 (至少有左子節點 2k)
            int j = 2*k; // j 指向左子節點
            if (j < N && less(j, j+1)) { // 如果有右子節點 (j < N) 且右子節點更大
                j++; // j 指向較大的子節點 (右子節點)
            }
            // 現在 j 指向 k 的較大的子節點 (如果存在的話)
            if (!less(k, j)) { // 如果 k 的鍵不小於其較大子節點的鍵，堆積順序滿足
                break;
            }
            exch(k, j); // 交換 k 與其較大子節點
            k = j; // 移動到較大子節點的位置繼續檢查
        }
    }
    ```
-   **成本:** 最多 $2 \log N$ 次比較和 $\log N$ 次交換 (每次比較兩個子節點，然後與父節點比較)。

### 優先佇列操作實現

使用最大堆積實現優先佇列：

-   **插入 (Insert):**
    1.  將新元素添加到陣列的末尾 (即完全二元樹的下一個可用位置)。
    2.  增加堆積大小 `N`。
    3.  對新加入的元素執行 `swim(N)` 操作，以恢復堆積順序。
    -   成本: $O(\log N)$。

-   **刪除最大元素 (Delete Max):**
    1.  最大元素位於根節點 `pq[1]`。
    2.  將根節點與堆積中的最後一個元素 `pq[N]` 交換。
    3.  減小堆積大小 `N--` (邏輯上移除了原來的最大元素，現在位於 `pq[N+1]`)。
    4.  對新的根節點 `pq[1]` (原來是 `pq[N]`) 執行 `sink(1, N)` 操作，以恢復堆積順序。
    5.  返回原來的最大元素。
    -   成本: $O(\log N)$。

-   **查看最大元素 (Max):** 直接返回 `pq[1]`。成本 $O(1)$。

## 堆積排序 (Heapsort) [[演算法筆記_總覽與考試重點]]

堆積排序是一種基於二元堆積的**原地 (in-place)** 比較排序演算法。

### 演算法步驟

1.  **堆積建構階段 (Heap Construction / Heapify):**
    -   將輸入的無序陣列轉換成一個最大堆積。
    -   可以從陣列的中間位置 ($\lfloor N/2 \rfloor$) 開始，向前到第一個元素，對每個元素執行 `sink` 操作。
    -   為什麼從 $\lfloor N/2 \rfloor$ 開始？因為索引大於 $\lfloor N/2 \rfloor$ 的元素都是葉節點，它們自身已經是合法的 (大小為1的) 堆積。
    -   **順序:** 從右向左，從下向上地 `sink`。
    ```java
    // 假設陣列 a 的索引從 0 到 N-1，我們將其視為索引從 1 到 N 的堆積
    // 為了方便，可以直接修改陣列使其索引從 1 開始，或者在 sink/swim 中調整索引
    // 這裡假設使用 1-based indexing for heap operations on array a
    // N 是陣列長度
    for (int k = N/2; k >= 1; k--) {
        sink(a, k, N); // sink 作用於子堆積 a[k...N]
    }
    ```
    -   **成本:** 這個階段令人驚訝地只需要 $O(N)$ 的時間 (線性時間)，而不是 $O(N \log N)$。雖然有 $N/2$ 次 `sink` 操作，每次 `sink` 最多 $\log N$，但大部分 `sink` 操作作用於較淺的子樹。
        -   高度為 $h$ 的節點，`sink` 最多移動 $h$ 層。
        -   第 $i$ 層 (從下往上，葉節點為第0層) 約有 $N/2^{i+1}$ 個節點，`sink` 成本為 $O(i)$。
        -   總成本 $\sum_{i=0}^{\log N} (N/2^{i+1}) \cdot O(i) = O(N)$。

2.  **排序階段 (Sortdown):**
    -   重複 $N-1$ 次以下操作：
        a.  將堆積的根節點 (當前陣列中的最大元素，位於 `a[1]`) 與堆積的最後一個元素 (位於 `a[k]`, $k$ 從 $N$ 遞減到 $2$) 交換。
        b.  此時，最大的元素被放置到了陣列的正確排序位置 (陣列末尾)。
        c.  將堆積的大小減 1 (邏輯上排除已排序的最大元素)。
        d.  對新的根節點 `a[1]` 執行 `sink(a, 1, k-1)` 操作，以恢復堆積的堆積順序 (作用於 `a[1...k-1]`)。
    ```java
    int currentHeapSize = N;
    while (currentHeapSize > 1) {
        exch(a, 1, currentHeapSize--); // 交換 a[1] 與 a[currentHeapSize]，然後減小堆積大小
        sink(a, 1, currentHeapSize);   // 在 a[1...currentHeapSize] 上恢復堆積
    }
    ```
    -   **成本:** 進行 $N-1$ 次 `delMax` 操作 (交換 + `sink`)。每次 `sink` 的成本是 $O(\log N)$。總成本 $O(N \log N)$。

### 總體效能

-   **時間複雜度:**
    -   堆積建構: $O(N)$
    -   排序階段: $O(N \log N)$
    -   總時間複雜度: $O(N \log N)$。
-   **空間複雜度:** $O(1)$ (如果原地實現，不計算輸入陣列本身)。這是堆積排序相對於合併排序的一個主要優勢。
-   **穩定性 (Stability):** 堆積排序**不是**穩定的。在 `sink` 或交換過程中，相等鍵的元素的相對順序可能會改變。

### 特點總結

-   **優點:**
    -   $N \log N$ 的最壞情況時間複雜度保證。
    -   原地排序，空間效率高。
-   **缺點:**
    -   內部迴圈比快速排序長 (常數因子較大)。
    -   對快取 (cache) 的利用不佳 (陣列存取模式不連續)。
    -   不是穩定的。

儘管如此，堆積排序仍然是一種重要的演算法，特別是在需要 $N \log N$ 最壞情況保證且空間受限的場景。