# 移位與旋轉指令

本節介紹 ARM 處理器中的移位和旋轉指令，包括邏輯左移、邏輯右移、算術右移、循環右移等操作。

## 移位指令概述

移位操作在數位系統中非常重要，可用於乘除法、位元操作、資料封裝等。ARM 提供了多種移位和旋轉指令，可以作為獨立指令使用，也可以作為其他指令的一部分。

## 邏輯左移 (LSL)

```assembly
LSL Rd, Rm, #n     ; Rd = Rm << n
LSLS Rd, Rm, #n    ; 同上，並更新旗標
```

邏輯左移 (Logical Shift Left) 將 Rm 中的所有位元向左移動 n 位，低位補 0，移出的高位進入 C 旗標。

**特性**：
- 每左移一位，值乘以 2
- 可能會丟失高位資訊
- 低位補 0

**範例**：
```assembly
MOV R0, #5         ; R0 = 5 (0b0101)
LSL R0, R0, #2     ; R0 = 20 (0b10100)，左移 2 位
```

## 邏輯右移 (LSR)

```assembly
LSR Rd, Rm, #n     ; Rd = Rm >> n (無號數)
LSRS Rd, Rm, #n    ; 同上，並更新旗標
```

邏輯右移 (Logical Shift Right) 將 Rm 中的所有位元向右移動 n 位，高位補 0，移出的低位進入 C 旗標。

**特性**：
- 每右移一位，值除以 2 (無號數)
- 可能會丟失低位資訊
- 高位補 0

**範例**：
```assembly
MOV R0, #20        ; R0 = 20 (0b10100)
LSR R0, R0, #2     ; R0 = 5 (0b0101)，右移 2 位
```

## 算術右移 (ASR)

```assembly
ASR Rd, Rm, #n     ; Rd = Rm >> n (有號數)
ASRS Rd, Rm, #n    ; 同上，並更新旗標
```

算術右移 (Arithmetic Shift Right) 將 Rm 中的所有位元向右移動 n 位，高位補充原始符號位，移出的低位進入 C 旗標。

**特性**：
- 每右移一位，值除以 2 (有號數)
- 保持符號不變
- 高位補充原始符號位

**範例**：
```assembly
MOV R0, #-20       ; R0 = -20 (0xFFFFFFEC)
ASR R0, R0, #2     ; R0 = -5 (0xFFFFFFFB)，右移 2 位，高位補 1
```

## 循環右移 (ROR)

```assembly
ROR Rd, Rm, #n     ; Rd = Rm ROR n
RORS Rd, Rm, #n    ; 同上，並更新旗標
```

循環右移 (Rotate Right) 將 Rm 中的所有位元向右移動 n 位，移出的低位循環填入高位，最後移出的位元進入 C 旗標。

**特性**：
- 不會丟失任何位元資訊
- 位元在 32 位元範圍內循環

**範例**：
```assembly
MOV R0, #0x12345678
ROR R0, R0, #8     ; R0 = 0x78123456，右移 8 位，低 8 位移到高 8 位
```

## 帶擴展的循環右移 (RRX)

```assembly
RRX Rd, Rm         ; Rd = (C:Rm) >> 1
RRXS Rd, Rm        ; 同上，並更新旗標
```

帶擴展的循環右移 (Rotate Right with Extend) 是一種特殊的移位操作，將 C 旗標和 Rm 一起視為 33 位元值，向右移動 1 位。C 旗標移入最高位，最低位移出到 C 旗標。

**特性**：
- 33 位元旋轉 (包含 C 旗標)
- 只能移動 1 位

**範例**：
```assembly
MOV R0, #0x12345678
MOVS R1, #1        ; 設置 C 旗標為 1
RRXS R0, R0        ; R0 = 0x8912345，C = 0
```

## 移位數來源

移位數可以來自立即值或暫存器：

### 立即值移位

```assembly
LSL Rd, Rm, #n     ; 立即值移位
```

立即值移位在編譯時確定，範圍通常為 0-31。

### 暫存器移位

```assembly
LSL Rd, Rm, Rs     ; 暫存器移位
```

暫存器移位使用 Rs 的值作為移位數，只使用 Rs 的低 8 位。

## 作為第二操作數的移位

移位操作可以作為其他指令的第二操作數的一部分：

```assembly
ADD Rd, Rn, Rm, LSL #n    ; Rd = Rn + (Rm << n)
```

這種形式允許在執行其他操作的同時進行移位，提高效率。

**範例**：
```assembly
; 計算 R0 = R1 + R2 * 4
ADD R0, R1, R2, LSL #2
```

## 移位操作的應用

### 快速乘除法

```assembly
; 乘法：R0 = R0 * 8
LSL R0, R0, #3     ; 左移 3 位，相當於乘以 2^3

; 除法：R0 = R0 / 4 (無號數)
LSR R0, R0, #2     ; 右移 2 位，相當於除以 2^2

; 除法：R0 = R0 / 4 (有號數)
ASR R0, R0, #2     ; 算術右移 2 位，相當於除以 2^2
```

### 位元提取

```assembly
; 提取 R0 的第 8-15 位到 R1
LSR R1, R0, #8     ; 右移 8 位，將目標位元移到低位
AND R1, R1, #0xFF  ; 只保留低 8 位
```

### 位元封裝

```assembly
; 將 R1 (低 8 位) 放入 R0 的第 16-23 位
LSL R1, R1, #16    ; 左移 16 位，將 R1 移到目標位置
BIC R0, R0, #0xFF0000  ; 清除 R0 的目標位元
ORR R0, R0, R1     ; 合併 R1 到 R0
```

### 循環緩衝區索引

```assembly
; 循環緩衝區索引 (大小為 2^n)
ADD R0, R0, #1     ; 增加索引
AND R0, R0, #0x0F  ; 限制在 0-15 範圍內 (16 個元素)

; 或使用 ROR 實現類似功能
ADD R0, R0, #1     ; 增加索引
CMP R0, #16        ; 檢查是否超出範圍
MOVHS R0, #0       ; 如果超出，重置為 0
```

## 返回

- [[ARM算術與邏輯指令|返回第三章目錄]]
- [[微處理機概述|返回微處理機概述]]
