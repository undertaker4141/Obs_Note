# 時間延遲實作

本節介紹在 ARM 處理器中實作時間延遲的方法，包括指令週期、流水線、分支懲罰等概念，以及如何計算和實現精確的時間延遲。

## 時間延遲的重要性

在嵌入式系統中，時間延遲是一個常見的需求，用於：
- 控制 I/O 裝置的時序
- 實現通訊協定的時間要求
- 產生特定頻率的信號
- 等待外部事件或硬體穩定

## 影響指令執行時間的因素

### 核心時脈頻率

處理器的時脈頻率直接影響指令執行速度。例如，在 72MHz 的 STM32F103 上，一個時脈週期為 1/72,000,000 秒 (約 13.9 納秒)。

### CPU 設計 (RISC 流水線)

ARM Cortex-M 是 RISC (精簡指令集) 處理器，採用流水線設計：
- 大多數指令在 1-3 個時脈週期內完成
- 指令執行被分解為多個階段 (取指、解碼、執行等)
- 流水線允許多個指令的不同階段同時執行

## 指令週期

指令週期是執行一條指令所需的時間。在 ARM Cortex-M 處理器中：
- 大多數資料處理指令 (ADD, SUB, MOV 等) 需要 1 個週期
- 記憶體存取指令 (LDR, STR) 通常需要 2 個週期
- 乘法指令 (MUL) 可能需要 1-3 個週期
- 除法指令 (如果支援) 可能需要 2-12 個週期

## 流水線 (Pipelining)

流水線是一種處理器設計技術，將指令執行分解為多個階段，並允許多個指令的不同階段同時執行。

### 典型的 ARM Cortex-M 流水線階段

1. **取指 (Fetch)**：從記憶體讀取指令
2. **解碼 (Decode)**：解析指令，確定操作和操作數
3. **執行 (Execute)**：執行指令，進行算術或邏輯運算
4. **記憶體 (Memory)**：存取記憶體 (如果需要)
5. **寫回 (Writeback)**：將結果寫回暫存器

### 流水線效率

流水線可以顯著提高處理器的吞吐量，但在某些情況下會受到影響：
- 資料相依性可能導致流水線停頓
- 分支指令可能導致流水線清空和重新填充

## 分支懲罰 (Branch Penalty)

分支懲罰是指當分支指令 (如 B, BL, BX) 改變程式流程時，流水線需要清空並重新填充，導致額外的時脈週期延遲。

### 分支懲罰特性

- 當分支發生 (條件滿足) 時，通常會有約 3 個週期的懲罰
- 當分支不發生 (條件不滿足) 時，通常只有 1 個週期的延遲
- 某些處理器有分支預測功能，可以減少分支懲罰

## 延遲迴圈計算

要計算延遲迴圈的時間，需要估算迴圈內指令的總週期數，然後乘以迴圈次數。

### 簡單延遲迴圈範例

```assembly
    MOV R0, #1000    ; 1 週期
Loop:
    SUBS R0, R0, #1  ; 1 週期
    BNE Loop         ; 1 週期 (不跳轉) 或 3 週期 (跳轉)
```

在這個範例中：
- 每次迴圈迭代需要 1 (SUBS) + 3 (BNE 跳轉) = 4 週期
- 最後一次迭代需要 1 (SUBS) + 1 (BNE 不跳轉) = 2 週期
- 總週期數 = 1 (MOV) + 4 * 999 (迴圈迭代) + 2 (最後一次) = 4,000 週期
- 在 72MHz 時脈下，這相當於約 55.6 微秒

### 使用 NOP 指令

`NOP` (No Operation) 指令用於空耗時間，不執行任何實際操作：

```assembly
    MOV R0, #1000    ; 設定迴圈計數
Loop:
    NOP              ; 空操作，1 週期
    NOP              ; 空操作，1 週期
    SUBS R0, R0, #1  ; 遞減計數器，1 週期
    BNE Loop         ; 條件分支，1 或 3 週期
```

## 毫秒延遲函式

以下是一個使用組合語言實現的毫秒延遲函式範例：

```assembly
; 延遲 R0 毫秒 (假設 72MHz 時脈)
Delay_ms:
    PUSH {R1, R2, LR}
    
    LDR R1, =72000   ; 每毫秒的週期數 (72MHz / 1000)
    
OuterLoop:
    MOV R2, R1       ; 載入內層迴圈計數
    
InnerLoop:
    SUBS R2, R2, #1  ; 遞減內層計數
    BNE InnerLoop    ; 繼續內層迴圈
    
    SUBS R0, R0, #1  ; 遞減毫秒計數
    BNE OuterLoop    ; 繼續外層迴圈
    
    POP {R1, R2, PC}
```

## 使用 SysTick 定時器

雖然軟體延遲迴圈簡單，但它們不精確且會阻塞 CPU。更好的方法是使用硬體定時器，如 SysTick：

```assembly
; 初始化 SysTick 定時器 (1ms 中斷)
SysTick_Init:
    LDR R0, =0xE000E010         ; SysTick 控制暫存器位址
    
    ; 設定重載值 (72000-1 為 1ms @ 72MHz)
    LDR R1, =71999
    STR R1, [R0, #4]            ; 寫入 LOAD 暫存器
    
    ; 清除目前值
    MOV R1, #0
    STR R1, [R0, #8]            ; 寫入 VAL 暫存器
    
    ; 啟用 SysTick，使用處理器時脈，啟用中斷
    MOV R1, #7                  ; ENABLE | TICKINT | CLKSOURCE
    STR R1, [R0]                ; 寫入 CTRL 暫存器
    
    BX LR

; 使用 SysTick 延遲 R0 毫秒
Delay_ms:
    PUSH {R1, LR}
    
    LDR R1, =0x20000000         ; 假設在 RAM 中有一個計數器變數
    STR R0, [R1]                ; 設定延遲計數
    
Wait_Loop:
    LDR R0, [R1]                ; 讀取計數器
    CMP R0, #0                  ; 檢查是否為零
    BNE Wait_Loop               ; 如果非零，繼續等待
    
    POP {R1, PC}

; SysTick 中斷處理程序
SysTick_Handler:
    PUSH {R0, R1, LR}
    
    LDR R1, =0x20000000         ; 計數器變數位址
    LDR R0, [R1]                ; 讀取計數器
    CMP R0, #0                  ; 檢查是否為零
    BEQ Skip_Decrement          ; 如果已經為零，跳過遞減
    
    SUBS R0, R0, #1             ; 遞減計數器
    STR R0, [R1]                ; 儲存更新後的值
    
Skip_Decrement:
    POP {R0, R1, PC}
```

## 延遲的最佳實踐

1. **對於短延遲 (微秒級)**：
   - 使用校準過的軟體延遲迴圈
   - 考慮使用 NOP 指令序列

2. **對於中等延遲 (毫秒級)**：
   - 使用硬體定時器 (如 SysTick)
   - 避免阻塞 CPU

3. **對於長延遲 (秒級或更長)**：
   - 使用硬體定時器
   - 考慮進入低功耗模式
   - 使用中斷驅動的方法

4. **精確延遲**：
   - 校準延遲迴圈
   - 考慮時脈頻率變化
   - 考慮中斷對延遲的影響

## 返回

- [[ARM分支呼叫與迴圈|返回第四章目錄]]
- [[微處理機概述|返回微處理機概述]]
