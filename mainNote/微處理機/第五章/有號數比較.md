# 有號數比較

本節介紹 ARM 處理器中的有號數比較方法和條件分支指令，包括 CMP 指令、CMN 指令以及有號數條件碼。

## 有號數比較概述

有號數比較是根據數值的符號和大小來確定它們之間的關係。與無號數比較不同，有號數比較需要考慮符號位，並使用不同的條件碼。

## CMP 指令

```assembly
CMP Rn, Op2    ; 比較 Rn 和 Op2 (Rn - Op2)，只更新旗標
```

CMP 指令執行減法操作但不儲存結果，只更新 CPSR 中的旗標。對於有號數比較，主要關注 N 和 V 旗標。

**範例**：
```assembly
    MOV R0, #-10     ; R0 = -10
    MOV R1, #5       ; R1 = 5
    CMP R0, R1       ; 比較 R0 和 R1 (-10 - 5)
    ; 結果：N=1 (負數)，Z=0 (非零)，V=0 (無溢位)
```

## CMN 指令

```assembly
CMN Rn, Op2    ; 比較 Rn 和 -Op2 (Rn + Op2)，只更新旗標
```

CMN (Compare Negative) 指令執行加法操作但不儲存結果，只更新旗標。它相當於比較 `Rn` 和 `-Op2`。

**範例**：
```assembly
    MOV R0, #-10     ; R0 = -10
    MOV R1, #-5      ; R1 = -5
    CMN R0, R1       ; 比較 R0 和 -R1 (-10 + 5)
    ; 結果：N=1 (負數)，Z=0 (非零)，V=0 (無溢位)
```

## 有號數條件碼

ARM 提供了一組條件碼，用於有號數比較後的條件執行或分支：

- **EQ** (Equal)：Z=1，相等
- **NE** (Not Equal)：Z=0，不相等
- **GT** (Greater Than)：Z=0 且 N=V，大於
- **LT** (Less Than)：N≠V，小於
- **GE** (Greater or Equal)：N=V，大於等於
- **LE** (Less or Equal)：Z=1 或 N≠V，小於等於
- **MI** (Minus)：N=1，負數
- **PL** (Plus)：N=0，正數或零
- **VS** (Overflow Set)：V=1，溢位
- **VC** (Overflow Clear)：V=0，無溢位

### 條件碼的邏輯

有號數比較的條件碼基於 N 和 V 旗標的關係：

- **大於 (GT)**：Z=0 且 N=V
  - 結果非零 (Z=0)
  - 結果符號與溢位狀態一致 (N=V)

- **小於 (LT)**：N≠V
  - 結果符號與溢位狀態不一致

- **大於等於 (GE)**：N=V
  - 結果符號與溢位狀態一致

- **小於等於 (LE)**：Z=1 或 N≠V
  - 結果為零 (Z=1) 或結果符號與溢位狀態不一致 (N≠V)

## 有號數條件分支

有號數條件分支指令根據 CPSR 中的旗標狀態決定是否跳轉：

```assembly
    CMP R0, R1       ; 比較 R0 和 R1
    BGT Greater      ; 如果 R0 > R1，跳轉到 Greater
    BLT Less         ; 如果 R0 < R1，跳轉到 Less
    BEQ Equal        ; 如果 R0 = R1，跳轉到 Equal
```

## 有號數比較範例

### 基本比較

```assembly
    ; 比較兩個有號數
    MOV R0, #-10     ; R0 = -10
    MOV R1, #5       ; R1 = 5
    CMP R0, R1       ; 比較 R0 和 R1
    BGT Greater      ; 如果 R0 > R1，跳轉到 Greater
    BLT Less         ; 如果 R0 < R1，跳轉到 Less
    B Equal          ; 否則 R0 = R1，跳轉到 Equal
    
Greater:
    ; R0 > R1 的處理程式碼
    ...
    
Less:
    ; R0 < R1 的處理程式碼 (會執行這部分)
    ...
    
Equal:
    ; R0 = R1 的處理程式碼
    ...
```

### 範圍檢查

```assembly
    ; 檢查 R0 是否在 [-10, 10] 範圍內
    MOV R1, #-10     ; 下限
    MOV R2, #10      ; 上限
    
    CMP R0, R1       ; 比較 R0 和下限
    BLT OutOfRange   ; 如果 R0 < -10，跳轉到 OutOfRange
    
    CMP R0, R2       ; 比較 R0 和上限
    BGT OutOfRange   ; 如果 R0 > 10，跳轉到 OutOfRange
    
    ; R0 在範圍內的處理程式碼
    ...
    
OutOfRange:
    ; R0 超出範圍的處理程式碼
    ...
```

### 排序

```assembly
    ; 對 R0, R1, R2 中的三個有號數進行排序 (從小到大)
    CMP R0, R1       ; 比較 R0 和 R1
    BLE Check_R1_R2  ; 如果 R0 <= R1，檢查 R1 和 R2
    
    ; 交換 R0 和 R1
    MOV R3, R0
    MOV R0, R1
    MOV R1, R3
    
Check_R1_R2:
    CMP R1, R2       ; 比較 R1 和 R2
    BLE Check_R0_R1  ; 如果 R1 <= R2，檢查 R0 和 R1
    
    ; 交換 R1 和 R2
    MOV R3, R1
    MOV R1, R2
    MOV R2, R3
    
Check_R0_R1:
    CMP R0, R1       ; 再次比較 R0 和 R1
    BLE Done         ; 如果 R0 <= R1，排序完成
    
    ; 交換 R0 和 R1
    MOV R3, R0
    MOV R0, R1
    MOV R1, R3
    
Done:
    ; 現在 R0 <= R1 <= R2
```

## 有號數與無號數比較的區別

有號數和無號數比較使用不同的條件碼：

### 有號數條件碼

- **GT** (Greater Than)：Z=0 且 N=V
- **LT** (Less Than)：N≠V
- **GE** (Greater or Equal)：N=V
- **LE** (Less or Equal)：Z=1 或 N≠V

### 無號數條件碼

- **HI** (Higher)：C=1 且 Z=0
- **LO/CC** (Lower)：C=0
- **HS/CS** (Higher or Same)：C=1
- **LS** (Lower or Same)：C=0 或 Z=1

**範例**：
```assembly
    MOV R0, #0xFFFFFFFF    ; R0 = -1 (有號數) 或 4294967295 (無號數)
    MOV R1, #10            ; R1 = 10
    
    CMP R0, R1
    BGT SignedGreater      ; 不會跳轉，因為 -1 < 10
    BHI UnsignedHigher     ; 會跳轉，因為 4294967295 > 10
```

## 特殊情況處理

### 溢位檢查

```assembly
    ; 執行有號數加法並檢查溢位
    ADDS R0, R1, R2    ; R0 = R1 + R2，更新旗標
    BVS Overflow       ; 如果發生溢位，跳轉到 Overflow
    
    ; 正常處理...
    
Overflow:
    ; 溢位處理...
```

### 符號檢查

```assembly
    ; 檢查 R0 的符號
    CMP R0, #0       ; 比較 R0 和 0
    BEQ Zero         ; 如果 R0 = 0，跳轉到 Zero
    BMI Negative     ; 如果 R0 < 0，跳轉到 Negative
    B Positive       ; 否則 R0 > 0，跳轉到 Positive
```

## 返回

- [[ARM有號整數運算|返回第五章目錄]]
- [[微處理機概述|返回微處理機概述]]
