---
banner: 模板/banner.jpg
banner_y: "86"
---
# 演算法筆記 第 10 講：最小生成樹 (Minimum Spanning Tree, MST)

[[演算法筆記_總覽與考試重點]]

## 最小生成樹 (Minimum Spanning Tree) [[演算法筆記_總覽與考試重點]]

### 定義

- **輸入:** 一個**連通的、無向的、帶權重的圖 (Connected, Undirected, Edge-weighted Graph)** G=(V,E)。邊的權重通常是正數。
    
- **生成樹 (Spanning Tree):**
    
    - 圖 G 的一個子圖 T。
        
    - T 包含 G 中所有的頂點 (V 個頂點)。
        
    - T 是連通的。
        
    - T 是無環的 (即 T 是一棵樹)。
        
    - 對於一個包含 V 個頂點的圖，其任何生成樹都恰好有 V−1 條邊。
        
- **最小生成樹 (MST):**
    
    - 在所有可能的生成樹中，邊權重之和最小的那棵生成樹。
        
    - 一個圖可能有多個最小生成樹 (如果存在相同權重的邊導致有多種選擇)。
        

### 應用

- 網路設計：以最低成本連接所有節點 (例如，鋪設電纜、設計通訊網路)。
    
- 聚類分析：將數據點分組。
    
- 圖像處理。
    
- 近似演算法：作為解決更複雜問題 (如旅行商問題) 的一部分。
    

### 切割性質 (Cut Property) - MST 的核心理論

這是設計 MST 演算法的基礎。

- **切割 (Cut):** 將圖的頂點集合 V 分割成兩個非空且不相交的子集 S 和 V−S。
    
- **跨越邊 (Crossing Edge):** 一條連接集合 S 中的一個頂點與集合 V−S 中的一個頂點的邊。
    
- **切割性質敘述:** 對於圖中的任意一個切割 (S,V−S)，如果存在一條跨越邊 (u,v)，其權重嚴格小於所有其他跨越該切割的邊的權重，那麼這條邊 (u,v) **必定屬於**圖的某個 (或所有) 最小生成樹。 更通用的說法是：對於任意切割，所有權重最小的跨越邊中，至少有一條屬於某個最小生成樹。如果這樣的最小權重跨越邊唯一，則它必定屬於所有最小生成樹。
    
- **證明思路 (反證法):**
    
    1. 假設最小權重跨越邊 e=(u,v) (對於某個切割) 不在任何 MST T∗ 中。
        
    2. 將 e 加入 T∗ 會形成一個環。
        
    3. 在這個環中，除了 e 之外，必然存在另一條邊 f 也是跨越同一個切割的 (因為環必須穿過切割兩次)。
        
    4. 由於 e 是最小權重的跨越邊，所以 weight(e)≤weight(f)。如果 weight(e)<weight(f)，則從 T∗ 中移除 f 並加入 e，會得到一個權重更小的生成樹 T′=T∗−f+e。這與 T∗ 是 MST 矛盾。
        
    5. 如果 weight(e)=weight(f)，則 T′ 也是一個 MST，且包含 e。
        

### 貪婪演算法思想

切割性質啟發了多種貪婪演算法來建構 MST。這些演算法逐步將邊加入到一個初始為空的集合中，直到形成一棵生成樹，並在每一步都做出局部最優的選擇 (選擇某條安全的邊)。

## Kruskal 演算法

- **思想:** 按照邊的權重**從小到大**的順序處理所有邊。如果一條邊連接了兩個先前不連通的頂點集合 (即加入該邊不會形成環)，則將該邊加入 MST。
    
- **演算法步驟:**
    
    1. 初始化一個空的邊集合 `mst` (用於存儲 MST 的邊)。
        
    2. 將圖 G 中的所有邊 E 按照權重非遞減排序。
        
    3. 初始化一個並查集 (Union-Find) 資料結構，其中每個頂點最初都屬於其自身的集合。
        
    4. 遍歷排序後的邊列表中的每條邊 (u,v)： a. 如果頂點 u 和頂點 v 不在同一個連通分量中 (即 `find(u) != find(v)`)： i. 將邊 (u,v) 加入 `mst`。 ii. 合併 u 和 v 所在的集合 (`union(u, v)`)。 b. 如果 `mst` 中的邊數達到 V−1，則演算法結束。
        
- **正確性證明:**
    
    - Kruskal 演算法是貪婪演算法的一個特例。
        
    - 當考慮一條邊 e=(u,v) 時，如果 u 和 v 屬於不同的連通分量 (由已加入 MST 的邊形成)，那麼這些連通分量可以看作是某個切割的一部分。
        
    - 由於邊是按權重排序的，e 是當前所有尚未形成環的邊中權重最小的。如果 e 連接的兩個分量 Cu​ 和 Cv​ 構成一個切割 (Cu​,V−Cu​)，那麼 e 就是這個切割的一條最小權重跨越邊 (因為任何其他連接 Cu​ 和 V−Cu​ 的邊，如果權重更小，會先被考慮；如果權重更大，則 e 優先)。根據切割性質，e 屬於 MST。
        
- **資料結構:**
    
    - 優先佇列 (Min Priority Queue) 或直接排序：用於按權重處理邊。
        
    - 並查集 (Union-Find)：用於高效檢測加入邊是否會形成環，並維護連通分量。
        
- **時間複雜度:**
    
    - 對 E 條邊排序: O(ElogE)。
        
    - 遍歷 E 條邊，每次執行 `find` (最多 2E 次) 和 `union` (最多 V−1 次) 操作。使用路徑壓縮和加權合併的並查集，這些操作的均攤成本接近常數 (實際上是 O(α(V))，其中 α 是反阿克曼函數，非常小)。
        
    - 總時間複雜度主要由排序決定: O(ElogE)。如果邊已經排序或者是 E 接近 V，則並查集操作的總成本可能是 O(Eα(V))。
        
    - 通常簡化為 O(ElogE) 或 O(ElogV) (因為 E≤V2，所以 logE≤2logV)。
        

## Prim 演算法

- **思想:** 從一個任意頂點開始，逐步擴展一棵樹 T。在每一步，選擇一條權重最小的邊，該邊連接樹 T 中的一個頂點與不在 T 中的一個頂點，並將該邊和相應的頂點加入 T。
    
- **演算法步驟 (Lazy Version):**
    
    1. 初始化一個空的邊集合 `mst`。
        
    2. 初始化一個布林陣列 `marked[V]`，標記已在樹 T 中的頂點，初始均為 `false`。
        
    3. 初始化一個最小優先佇列 `pq`，用於存儲所有**跨越邊** (一端在 T 中，另一端不在 T 中的邊)。
        
    4. 選擇一個起始頂點 s (例如頂點 0)，將其標記為 `marked[s] = true`。
        
    5. 將所有與 s 相連的邊加入 `pq`。
        
    6. 當 `pq` 不為空且 `mst` 中的邊數小於 V−1 時： a. 從 `pq` 中提取權重最小的邊 e=(u,v) (`delMin`)。 b. 檢查 e 的兩個端點 u 和 v： i. 如果 u 和 v 都已經被標記 (`marked[u]` 和 `marked[v]` 均為 `true`)，則 e 是連接 T 中兩個頂點的邊 (不是跨越邊，或者說是一個過時的邊)，忽略它，繼續下一輪。 ii. 否則 (至少有一個端點未標記)，將 e 加入 `mst`。 iii. 假設 v 是已標記的，u 是未標記的 (反之亦然)。將未標記的端點 (例如 u) 標記為 `marked[u] = true`。 iv. 對於新加入 T 的頂點 u，將其所有未連接到 T 中已標記頂點的鄰邊 (即連接 u 和某個 `!marked[w]` 的邊 (u,w)) 加入 `pq`。
        
- **正確性證明:**
    
    - Prim 演算法也是貪婪演算法的特例。
        
    - 在每一步，樹 T 中的頂點集合構成切割 (T,V−T)。Prim 選擇的邊是連接 T 和 V−T 的所有邊中權重最小的那條。根據切割性質，這條邊屬於 MST。
        
- **資料結構 (Lazy Prim):**
    
    - 最小優先佇列 `pq` (存儲邊)。
        
    - 布林陣列 `marked[]`。
        
    - 佇列 `mst` (存儲 MST 的邊)。
        
- **時間複雜度 (Lazy Prim):**
    
    - 每個頂點被訪問一次，其所有鄰邊被加入 `pq`。總共最多 E 次 `insert` 操作到 `pq`。
        
    - 最多 E 次 `delMin` 操作從 `pq`。
        
    - 使用二元堆積實現 `pq`，`insert` 和 `delMin` 都是 O(logE)。
        
    - 總時間複雜度: O(ElogE)。
        
    - 空間複雜度: O(E) (用於 `pq`)。
        
- **Prim 演算法 (Eager Version - 更優化):**
    
    - **思想:** 優先佇列中不直接存儲邊，而是存儲**不在樹** T **中的頂點**。每個頂點 v∈/T 在 `pq` 中的優先級是連接 v 到 T 的**最短**邊的權重。
        
    - 維護 `distTo[v]`：連接 v 到當前樹 T 的最短邊的權重。
        
    - 維護 `edgeTo[v]`：`distTo[v]` 對應的那條邊。
        
    - **步驟:**
        
        1. 初始化 `distTo[v] = \infty$ for all $v$,` distTo[s] = 0` (s為起點)。
            
        2. `pq` 存儲頂點，按 `distTo` 值排序。初始時 `pq` 包含所有頂點 (或只包含 s 並逐步添加)。
            
        3. 當 `pq` 不為空： a. 從 `pq` 中提取 `distTo` 值最小的頂點 `u` (`delMin`)。 b. 將 `u` 加入樹 T (標記 `u`)。將 `edgeTo[u]` (如果 u=s) 加入 MST。 c. 對於 `u` 的每個鄰接點 `v`： i. 如果 v 尚未在樹 T 中 (`!marked[v]`) 且邊 (u,v) 的權重 `weight(u,v)` 小於當前已知的 `distTo[v]`： - 更新 `distTo[v] = weight(u,v)`。 - 更新 `edgeTo[v] = (u,v)`。 - 如果 v 已在 `pq` 中，則調用 `decreaseKey(v, distTo[v])`。 - 如果 v 不在 `pq` 中，則調用 `insert(v, distTo[v])`。
            
    - **時間複雜度 (Eager Prim with Binary Heap):**
        
        - V 次 `delMin` 操作: V⋅O(logV)。
            
        - 最多 E 次邊鬆弛，可能導致 E 次 `decreaseKey` (或 `insert`) 操作: E⋅O(logV)。
            
        - 總時間複雜度: O((V+E)logV)=O(ElogV) (因為圖是連通的，E≥V−1)。
            
    - **時間複雜度 (Eager Prim with Fibonacci Heap):**
        
        - `decreaseKey` 操作均攤 O(1)。
            
        - 總時間複雜度: O(E+VlogV)。對於稠密圖 (E≈V2)，這比 O(ElogV) 更好。
            
    - 空間複雜度: O(V) (用於 `distTo`, `edgeTo`, `pq`)。
        

### Kruskal vs. Prim

- **Kruskal:**
    
    - 概念上更簡單。
        
    - 適用於邊列表已排序或易於排序的情況。
        
    - 時間複雜度 O(ElogE) 或 O(ElogV)。
        
- **Prim (Eager with Binary Heap):**
    
    - 時間複雜度 O(ElogV)。
        
    - 對於稠密圖 (E≈V2)，Prim (O(V2logV)) 可能比 Kruskal (O(V2logV2)=O(V2⋅2logV)) 略好或相當。
        
- **Prim (Eager with Fibonacci Heap):**
    
    - 時間複雜度 O(E+VlogV)。這是理論上最優的 MST 演算法之一，尤其對稠密圖有優勢。但在實踐中，Fibonacci Heap 的常數因子較大，二元堆積版本的 Prim 或 Kruskal 往往表現更好，除非圖非常大且稠密。
        

兩種演算法都是正確的，並且在許多情況下都能有效地找到最小生成樹。